<!DOCTYPE HTML>
<html lang="zh-cn" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>TensorStack AI 计算平台 - User Console 用户手册</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/sidebar.css">
        <link rel="stylesheet" href="theme/custom.css">
        <link rel="stylesheet" href="theme/version-dropdown.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">概述</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="homepage.html"><strong aria-hidden="true">1.</strong> 首页</a></li><li class="chapter-item expanded "><a href="storage/index.html"><strong aria-hidden="true">2.</strong> 存储</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="storage/volume.html"><strong aria-hidden="true">2.1.</strong> 创建 PVC</a></li><li class="chapter-item expanded "><a href="storage/adapter.html"><strong aria-hidden="true">2.2.</strong> 创建 StorageShim</a></li></ol></li><li class="chapter-item expanded "><a href="app/index.html"><strong aria-hidden="true">3.</strong> 应用</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app/jupyter-lab.html"><strong aria-hidden="true">3.1.</strong> 部署 JupyterLab</a></li><li class="chapter-item expanded "><a href="app/terminal.html"><strong aria-hidden="true">3.2.</strong> 部署 Terminal</a></li><li class="chapter-item expanded "><a href="app/filebrowser.html"><strong aria-hidden="true">3.3.</strong> 部署 FileBrowser</a></li><li class="chapter-item expanded "><a href="app/codeserver.html"><strong aria-hidden="true">3.4.</strong> 部署 CodeServer</a></li><li class="chapter-item expanded "><a href="app/tensorboard.html"><strong aria-hidden="true">3.5.</strong> 部署 TensorBoard</a></li><li class="chapter-item expanded "><a href="app/job-manager.html"><strong aria-hidden="true">3.6.</strong> 部署 Job Manager</a></li><li class="chapter-item expanded "><a href="app/postgresql.html"><strong aria-hidden="true">3.7.</strong> 部署 PostgreSQL</a></li></ol></li><li class="chapter-item expanded "><a href="network/index.html"><strong aria-hidden="true">4.</strong> 网络服务</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="network/service.html"><strong aria-hidden="true">4.1.</strong> 查看 Service</a></li><li class="chapter-item expanded "><a href="network/ingress.html"><strong aria-hidden="true">4.2.</strong> 查看 Ingress</a></li></ol></li><li class="chapter-item expanded "><a href="auxiliary/index.html"><strong aria-hidden="true">5.</strong> 辅助资源</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="auxiliary/secret.html"><strong aria-hidden="true">5.1.</strong> 创建 Secret</a></li><li class="chapter-item expanded "><a href="auxiliary/configmap.html"><strong aria-hidden="true">5.2.</strong> 创建 ConfigMap</a></li></ol></li><li class="chapter-item expanded "><a href="account/index.html"><strong aria-hidden="true">6.</strong> 账户设置</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="account/view-profile.html"><strong aria-hidden="true">6.1.</strong> 查看账户信息</a></li><li class="chapter-item expanded "><a href="account/project-management.html"><strong aria-hidden="true">6.2.</strong> 项目管理</a></li><li class="chapter-item expanded "><a href="account/security-setting.html"><strong aria-hidden="true">6.3.</strong> 安全设置</a></li><li class="chapter-item expanded "><a href="account/view-bill.html"><strong aria-hidden="true">6.4.</strong> 查看账单</a></li><li class="chapter-item expanded "><a href="account/alert-notification.html"><strong aria-hidden="true">6.5.</strong> 告警通知</a></li></ol></li><li class="chapter-item expanded "><a href="task/index.html"><strong aria-hidden="true">7.</strong> 任务</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="task/upload-and-download-file.html"><strong aria-hidden="true">7.1.</strong> 上传和下载文件</a></li><li class="chapter-item expanded "><a href="task/train-model/index.html"><strong aria-hidden="true">7.2.</strong> 训练模型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="task/train-model/dp-training.html"><strong aria-hidden="true">7.2.1.</strong> 进行数据并行训练</a></li><li class="chapter-item expanded "><a href="task/train-model/llm-large-scale-pretraining.html"><strong aria-hidden="true">7.2.2.</strong> 进行 LLM 大规模预训练</a></li><li class="chapter-item expanded "><a href="task/train-model/profile.html"><strong aria-hidden="true">7.2.3.</strong> 分析性能</a></li></ol></li><li class="chapter-item expanded "><a href="task/deploy-model/index.html"><strong aria-hidden="true">7.3.</strong> 部署模型推理服务</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="task/deploy-model/deploy-llm.html"><strong aria-hidden="true">7.3.1.</strong> 部署 LLM 推理服务和聊天服务</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        <!-- custom code for adding release version dropdown menu -->
                        <div class="version-dropdown">
                            <button id="release-version" class="icon-button" type="button" title="Release version" aria-label="Release version" aria-haspopup="true" aria-expanded="false" aria-controls="release-versions">
                                <i class="fa fa-book"></i>
                            </button>
                            <div class="version-dropdown-content">
                                <a href="https://t9k.github.io/user-manuals/latest/index.html"target="_blank" rel="noopener noreferrer">latest</a>
                                <a href="https://t9k.github.io/user-manuals/v20240206/index.html"target="_blank" rel="noopener noreferrer">v20240206</a>
                            </div>
                        </div>
                    </div>

                    <h1 class="menu-title">TensorStack AI 计算平台 - User Console 用户手册</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="概述"><a class="header" href="#概述">概述</a></h1>
<h2 id="目标读者"><a class="header" href="#目标读者">目标读者</a></h2>
<p>本书《TensorStack AI 计算平台 - User Console 用户手册》 的目标读者是 “TensorStack AI 计算平台” 的使用者，包括：</p>
<ul>
<li>AI 研究人员</li>
<li>建模工程师</li>
<li>数据处理工程师</li>
<li>机器学习工程师</li>
<li>AI 应用开发工程师等</li>
</ul>
<p>系统管理员、运维人员需要参考另外的《TensorStack AI 计算平台 - 管理员手册》系列。</p>
<h2 id="产品概述"><a class="header" href="#产品概述">产品概述</a></h2>
<p>TensorStack AI 计算平台是面向 AI 集群的系统软件，针对 AI 集群的硬件架构和 AI 领域的计算任务的特性和需求，提供稳定、可扩展的 AI 技术平台能力，服务 AI 技术研发、应用和规模化落地。</p>
<p>AI 集群的拥有者可以使用这套软件，构建自己的 AI 私有云或 AI 混合云基础设施服务。</p>
<aside class="note info">
<div class="title">TensorStack AI 计算平台的功能</div>
<p>产品提供两方面的能力：</p>
<ol>
<li><strong>计算服务</strong>：针对 AI 集群使用者，向上支持各种 AI 计算场景，例如云端开发环境、模型训练、部署推理服务、应用开发等；</li>
<li><strong>集群管理</strong>：针对 AI 集群的管理、运维人员，提供方便的机制，实施各种资源、安全、数据等管理策略。</li>
</ol>
</aside>
<p>通过先进的架构和丰富的 API + 应用，TensorStack AI 计算平台合理地隐藏了分布式并行、异构计算、加速计算等技术的复杂细节，提高了抽象层次，并为 AI 领域的各种计算提供了针对性的支持，极大地提升了 AI 技术研究、开发、应用的工作效率。</p>
<figure class="architecture">
  <img alt="t9k-arch" src="./assets/overview/t9k-arch.png" />
  <figcaption>图 1：TensorStack AI 计算平台构建了一个高效的 AI 基础设施能力。API 层提供了可扩展、可编程、云原生的系统服务；应用层（Apps）为多样化的应用场景提供全面、完善的支撑。用户可根据需求，安装各种 Apps（IDE、LLM 开发框架、并行训练管理、推理服务管理、资源管理工具、完整的 AI 应用等），满足 AI 研究、开发和应用等业务需求。</figcaption>
</figure>
<h2 id="用户控制台user-console"><a class="header" href="#用户控制台user-console">用户控制台（User Console）</a></h2>
<p><strong>用户控制台（User Console）</strong> 是 TensorStack AI 计算平台的 <strong>应用层</strong> 入口，为 <strong>AI 集群使用者</strong> 提供了一个集中使用集群功能的图形化使用界面。</p>
<p><strong>应用（Apps）</strong> 是 User Console 的核心，作为用户使用平台提供的所有功能的主要入口。无论是进行 AI 研究、开发还是部署，用户都是通过部署和使用相应的 Apps 来完成。例如：</p>
<ul>
<li>AI 研究员可能通过 <strong>JupyterLab 应用</strong> 作为其日常开发环境，使用 <strong>Job Manager 应用</strong> 运行和管理并行训练任务。</li>
<li>AI 应用工程师可能使用 <strong>vLLM 应用</strong> 或 <strong>Stable Diffusion WebUI 应用</strong> 来部署和测试 AI 模型。</li>
</ul>
<aside class="note info">
<div class="title">应用（Apps）为中心</div>
<p>这种以 Apps 为中心的设计使得用户：</p>
<ol>
<li>能够直观地访问和管理他们所需的所有 AI 相关工具和服务。</li>
<li>根据自己的偏好和习惯，及工作的性质，灵活的选择合适的 Apps。</li>
<li>可方便的通过安装新的 Apps 来获得能力扩展，随时使用 AI 领域的各种新技术个工具。</li>
</ol>
</aside>
<p>围绕 Apps，User Console 的其他功能都为其提供方便的支持。</p>
<ul>
<li><strong>持久卷（PV + PVC）</strong> 和 <strong>适配器（StorageShim）</strong> 支持应用能够持久化保存数据，存储模型、数据集和训练数据等。</li>
<li>网络服务如 <strong>Service</strong> 和 <strong>Ingress</strong>，为应用提供内部通信和外部访问的能力，使得应用能够相互协作并对外提供服务。</li>
<li>辅助资源如 <strong>Secret</strong> 和 <strong>ConfigMap</strong> 则为应用提供配置管理和敏感信息保护，确保应用能够安全且灵活地运行。</li>
</ul>
<p>除此之外，User Console 还提供了账户设置功能，帮助用户管理账户的项目和 API Key，接受账单和来自平台的告警信息。</p>
<h3 id="使用流程"><a class="header" href="#使用流程">使用流程</a></h3>
<p>用户使用 User Console 的基本交互流程如下：</p>
<ol>
<li>用户登陆系统</li>
<li>用户在项目中部署并使用 Apps，必要时创建存储、网络和辅助资源等</li>
<li>用户在 Apps 中完成工作（创建计算任务，部署推理服务，使用推理服务，等等）</li>
</ol>
<figure class="architecture">
  <img alt="use-user-console" src="./assets/overview/use-user-console.drawio.svg" />
  <figcaption>图 2：用户登陆系统后在项目中部署并使用 Apps 完成工作。</figcaption>
</figure>
<h2 id="下一步"><a class="header" href="#下一步">下一步</a></h2>
<p>进入 <a href="./homepage.html">User Console 首页</a></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="首页"><a class="header" href="#首页">首页</a></h1>
<p>首页是 “用户控制台（User Console）” 的起时界面，为用户提供功能快速入口，及账户的基本统计信息。</p>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<p>在开始使用 “User Console” 前，你需要：</p>
<ol>
<li>了解 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/security/account.html">账户</a> 和 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/security/project.html">项目</a> 的概念。</li>
<li>拥有一个账户，且该账户至少是一个项目的成员。</li>
</ol>
<p>User Console 首页包含以下元素：</p>
<ol>
<li>顶部导航栏（包括白色和蓝色两个导航栏）</li>
<li>左侧导航菜单</li>
<li>中间的各项功能和账户统计</li>
</ol>
<figure class="screenshot">
  <img alt="homepage" src="./assets/homepage.png" />
</figure>
<p>顶部白色导航栏的右侧有一些快捷按键，分别提供了以下功能：</p>
<ol>
<li><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2Z"/></svg></span>：使用 YAML 创建 K8s 资源</li>
<li><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m12.87 15.07-2.54-2.51.03-.03A17.52 17.52 0 0 0 14.07 6H17V4h-7V2H8v2H1v2h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04M18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12m-2.62 7 1.62-4.33L19.12 17h-3.24Z"/></svg></span>：切换语言</li>
<li><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11 18h2v-2h-2v2m1-16A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10A10 10 0 0 0 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-14a4 4 0 0 0-4 4h2a2 2 0 0 1 2-2 2 2 0 0 1 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5a4 4 0 0 0-4-4Z"/></svg></span>：打开用户文档</li>
<li><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 21h4c0 1.1-.9 2-2 2s-2-.9-2-2m11-2v1H3v-1l2-2v-6c0-3.1 2-5.8 5-6.7V4c0-1.1.9-2 2-2s2 .9 2 2v.3c3 .9 5 3.6 5 6.7v6l2 2m-4-8c0-2.8-2.2-5-5-5s-5 2.2-5 5v7h10v-7Z"/></svg></span>：显示当前账户订阅的告警信息</li>
<li><span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 19.2c-2.5 0-4.71-1.28-6-3.2.03-2 4-3.1 6-3.1s5.97 1.1 6 3.1a7.232 7.232 0 0 1-6 3.2M12 5a3 3 0 0 1 3 3 3 3 0 0 1-3 3 3 3 0 0 1-3-3 3 3 0 0 1 3-3m0-3A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10c0-5.53-4.5-10-10-10Z"/></svg></span>：显示当前用户信息，可用于退出登录</li>
</ol>
<p>蓝色面包屑导航栏的左侧可以显示/隐藏左侧导航菜单，右侧是手动刷新按键和自动刷新的开关。</p>
<p>左侧导航菜单和中间区域对应的各项功能在下文介绍。</p>
<h2 id="下一步-1"><a class="header" href="#下一步-1">下一步</a></h2>
<ul>
<li><a href="./storage/index.html">创建集群存储</a>，或者</li>
<li><a href="./app/index.html">部署应用</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="存储"><a class="header" href="#存储">存储</a></h1>
<p>存储负责为应用提供数据持久化。它包括存储卷和适配器两种资源，这些资源确保应用能够可靠地存储和访问数据。存储卷为应用提供了持久化的数据存储空间，而适配器则帮助应用连接和使用不同类型的外部存储系统（例如 S3）。</p>
<p>通过有效管理这些存储资源，用户能够灵活地处理大规模模型、数据集文件和其他 AI 开发过程中产生的数据，从而支持各种 AI 应用的高效运行和数据密集型任务的顺利进行。</p>
<h2 id="下一步-2"><a class="header" href="#下一步-2">下一步</a></h2>
<ul>
<li><a href="storage/./volume.html">创建 PVC</a></li>
<li>或者，了解 <a href="storage/../app/index.html">部署 Apps</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="创建-pvc"><a class="header" href="#创建-pvc">创建 PVC</a></h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/storage/pvc.html">PVC</a> 是一种 Kubernetes 原生资源，是对存储的需求声明。用户可以请求特定大小和访问模式的存储，而不必关心存储的具体实现。本章演示创建一个 PVC。</p>
<p>点击菜单<strong>存储 &gt; 存储卷</strong>，打开 PVC 的列表页面。然后点击右上角<strong>创建 PVC</strong>，进入 PVC 创建页面：</p>
<figure class="screenshot">
  <img alt="list-pvc" src="storage/../assets/storage/list-pvc.png" />
</figure>
<p>填写 PVC 的名称、存储空间大小，选择访问模式、存储类，确认右上角选择的项目，然后点击右上方的<strong>创建</strong>：</p>
<figure class="screenshot">
  <img alt="create-pvc" src="storage/../assets/storage/create-pvc.png" />
</figure>
<p>回到存储卷列表，可以看到刚创建的 PVC：</p>
<figure class="screenshot">
  <img alt="created-pvc" src="storage/../assets/storage/created-pvc.png" />
</figure>
<h2 id="下一步-3"><a class="header" href="#下一步-3">下一步</a></h2>
<ul>
<li><a href="storage/../app/index.html">部署 Apps</a></li>
<li>或者，了解 <a href="storage/./adapter.html">创建存储适配器（StorageShim)</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="创建-storageshim"><a class="header" href="#创建-storageshim">创建 StorageShim</a></h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/storage/storageshim.html">StorageShim</a> 用于将已有的存储系统以 PVC 的形式提供给用户使用，例如将分布式文件系统的某个子目录作为一个 PVC 使用。</p>
<h2 id="cephfs-类型"><a class="header" href="#cephfs-类型">CephFS 类型</a></h2>
<p>本章演示创建 CephFS 类型的存储适配器，将 CephFS 的一个子目录作为一个 PVC 使用。</p>
<p>在开始之前，你需要依靠从管理员处获得的信息，先完成<a href="storage/../auxiliary/secret.html">创建 Secret</a> 和<a href="storage/../auxiliary/configmap.html">创建 ConfigMap</a>。</p>
<p>点击菜单<strong>存储 &gt; 适配器</strong>，打开适配器的列表页面。然后点击右上角<strong>创建 StorageShim</strong>，进入创建页面：</p>
<figure class="screenshot">
  <img alt="list-storageshim" src="storage/../assets/storage/list-storageshim.png" />
</figure>
<p>选择类型为 CephFS，并选择提前创建好的 Ceph 服务器 ConfigMap 和 Ceph 客户端 Secret。其中的 ConfigMap 可以是管理员创建的公共配置，或者自己创建的私有配置：</p>
<figure class="screenshot">
  <img alt="create-storageshim-ceph-1" src="storage/../assets/storage/create-storageshim-ceph-1.png" />
</figure>
<p>然后填写名称和 CephFS 路径。如果不知道可用的 CephFS 路径信息，可以询问管理员。最后点击右上角的创建：</p>
<figure class="screenshot">
  <img alt="create-storageshim-ceph-2" src="storage/../assets/storage/create-storageshim-ceph-2.png" />
</figure>
<p>创建成功后，等待适配器就绪即可：</p>
<figure class="screenshot">
  <img alt="created-storageshim" src="storage/../assets/storage/created-storageshim.png" />
</figure>
<h2 id="s3-类型"><a class="header" href="#s3-类型">S3 类型</a></h2>
<p>本章演示创建 CephFS 类型的存储适配器，将 S3 的一个 bucket 或者 bucket 中的目录作为一个 PVC 使用。</p>
<p>在开始之前，你需要获取 S3 服务的信息，并创建一个 <a href="storage/../auxiliary/secret.html#s3-cfg-%E7%B1%BB%E5%9E%8B"><code>S3-cfg</code> 类型的 Secret</a>。</p>
<p>进入 StorageShim 创建页面，并选择类型为 S3：</p>
<figure class="screenshot">
  <img alt="create-storageshim-s3-1" src="storage/../assets/storage/create-storageshim-s3-1.png" />
</figure>
<p>填写名称、“S3 URI” 并选择 “S3 Secret”，将鼠标放在字段右侧的 <span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11 18h2v-2h-2v2m1-16A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10A10 10 0 0 0 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-14a4 4 0 0 0-4 4h2a2 2 0 0 1 2-2 2 2 0 0 1 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5a4 4 0 0 0-4-4Z"/></svg></span> 上可以看到详细的说明：</p>
<figure class="screenshot">
  <img alt="create-storageshim-s3-2" src="storage/../assets/storage/create-storageshim-s3-2.png" />
</figure>
<p>点击右上角的创建即可完成适配器的创建。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="应用"><a class="header" href="#应用">应用</a></h1>
<h2 id="概念"><a class="header" href="#概念">概念</a></h2>
<p><strong>应用（Apps）</strong> 是平台提供各种能力的功能模块，用户可根据自己的需求进行安装和使用。</p>
<p>这里的 Apps 既包括直接 AI 模型驱动的应用程序，例如 vLLM、Open WebUI、Stable Diffusion WebUI，也包含在 AI 研究、开发过程中可能使用到的软件、工具，例如 JupyterLab、PyCharm、TensorBoard、Dify 等。</p>
<p>并且，这些 Apps 可以通过共享存储、API 调用等方式进行协作。</p>
<p>用户在完成某一项任务时可以根据自己的偏好和任务的性质，灵活使用多个应用，进而高效地完成模型开发、训练、部署，AI 应用构建和部署等任务，全面开展与 AI 有关的工作，如下图示意：</p>
<figure class="architecture">
  <img alt="app" src="app/../assets/app/app.drawio.svg" />
</figure>
<p>例如：</p>
<p>1）在任务 <a href="app/../task/train-model/dp-training.html">进行数据并行训练</a> 中：</p>
<ul>
<li>用户在 JupyterLab 应用中进行交互式开发；</li>
<li>JupyterLab、TensorBoard 和 PyTorchTrainingJob 挂载同一个 PVC，通过文件系统共享数据；</li>
<li>在 JupyterLab 中拉取的训练代码可以被 PyTorchTrainingJob 执行；</li>
<li>PyTorchTrainingJob 中产生的 <code>tfevents</code> 日志文件可以被 TensorBoard 应用所读取并可视化展示。</li>
</ul>
<p>2） 在任务 <a href="app/../task/deploy-model/deploy-llm.html">部署 LLM 推理服务和聊天服务</a> 中：</p>
<ul>
<li>JupyterLab 和 vLLM 共享存储，在 JupyterLab 中下载的模型文件可以被 vLLM 应用所加载；</li>
<li>NextChat 调用 vLLM 的 LLM 推理服务 API；</li>
<li>用户通过 NextChat 提供的简洁美观的 UI 中与 vLLM 部署的 LLM 聊天。</li>
</ul>
<h2 id="运行中的-apps"><a class="header" href="#运行中的-apps">运行中的 Apps</a></h2>
<p>点击左侧导航菜单的<strong>应用</strong>，查看所有运行中（已经部署）的应用：</p>
<figure class="screenshot">
  <img alt="list-app" src="app/../assets/app/list-app.png" />
</figure>
<h2 id="安装-apps"><a class="header" href="#安装-apps">安装 Apps</a></h2>
<p>点击上图右上角的<strong>部署应用</strong>，查看所有可部署的应用：</p>
<figure class="screenshot">
  <img alt="app-catalog" src="app/../assets/app/app-catalog.png" />
</figure>
<h2 id="下一步-4"><a class="header" href="#下一步-4">下一步</a></h2>
<ul>
<li><a href="app/jupyter-lab.html">部署 JupyterLab</a></li>
<li>了解 <a href="app/../network/index.html">网络服务</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署-jupyterlab"><a class="header" href="#部署-jupyterlab">部署 JupyterLab</a></h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://jupyterlab.readthedocs.io/en/latest/">JupyterLab</a> 是一款非常流行的机器学习开发工具，它通过友好易用的 Web 界面提供交互式计算环境，支持多种编程语言和执行环境，在机器学习、AI、数据处理、数值模拟、统计建模、数据可视化等领域被广泛使用。</p>
<p>JupyterLab 系列应用包括 JupyterLab (CPU)、JupyterLab (NVIDIA GPU)、JupyterLab (Enflame GCU)、和 JupyterLab (Hygon DCU)，它们之间的区别仅在于支持不同的加速设备。本教程演示部署 JupyterLab (CPU) 应用。</p>
<p>点击 <strong>JupyterLab (CPU)</strong> 应用，进入 App 详情页面：</p>
<figure class="screenshot">
  <img alt="select-jupyter-lab" src="app/../assets/app/select-jupyter-lab.png" />
</figure>
<p>在 App 详情页面，你可以看到如何配置应用，这包含了可用镜像列表、示例 YAML 和参数说明。确认信息后，点击右上角的<strong>立刻部署</strong>进入创建页面：</p>
<figure class="screenshot">
  <img alt="readme-jupyter-lab" src="app/../assets/app/readme-jupyter-lab.png" />
</figure>
<p>点击上方的 <strong>README</strong> 再次查看说明信息，这些信息可以帮助你正确地设置 JupyterLab 的运行参数：</p>
<figure class="screenshot">
  <img alt="parameter-jupyter-lab" src="app/../assets/app/parameter-jupyter-lab.png" />
</figure>
<aside class="note tip">
<div class="title">提示</div>
<p>用户通常可以通过<strong>表单</strong>或者 <strong>YAML 编辑器</strong>进行应用的配置。前者提供了一个直观的界面，让你可以方便地填写和修改参数；而后者则需要你直接编辑 YAML 文件，适合熟悉 YAML 格式的资深用户使用。如果你不确定参数的含义，可以点击<strong>README</strong>标签页来查看各个参数的说明。</p>
</aside>
<p>较简单的配置方式是直接在<strong>表单</strong>标签页填写给出的字段：</p>
<figure class="screenshot">
  <img alt="form-jupyter-lab" src="app/../assets/app/form-jupyter-lab.png" />
</figure>
<p>熟悉 YAML 的用户可以在 <strong>YAML 编辑器</strong>标签页编辑相应的字段。配置完成后，点击右上角的<strong>部署</strong>：</p>
<figure class="screenshot">
  <img alt="yaml-jupyter-lab" src="app/../assets/app/yaml-jupyter-lab.png" />
</figure>
<p>等待创建成功的 JupyterLab 应用就绪：</p>
<figure class="screenshot">
  <img alt="wait-for-jupyter-lab" src="app/../assets/app/wait-for-jupyter-lab.png" />
</figure>
<p>应用就绪后，点击右侧的 <span class="twemoji"><svg class="MuiSvgIcon-root MuiSvgIcon-colorPrimary MuiSvgIcon-fontSizeMedium css-jxtyyz" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="OpenInNewIcon"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"></path></svg></span>，即可使用该应用：</p>
<figure class="screenshot">
  <img alt="ui-jupyter-lab" src="app/../assets/app/ui-jupyter-lab.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署-terminal"><a class="header" href="#部署-terminal">部署 Terminal</a></h1>
<p>Terminal 是一个通过 Web 使用的终端应用。用户可以在浏览器中连接到该终端以进行各项工作，包括使用 kubectl 管理 K8s 资源。本教程演示部署 Terminal 应用。</p>
<p>点击 <strong>Terminal</strong> 应用，进入 App 详情页面：</p>
<figure class="screenshot">
  <img alt="select-terminal" src="app/../assets/app/select-terminal.png" />
</figure>
<p>在 App 详情页面，你可以看到如何配置应用，这包含了示例 YAML 和参数说明。确认信息后，点击右上角的<strong>立刻部署</strong>进入创建页面：</p>
<figure class="screenshot">
  <img alt="readme-terminal" src="app/../assets/app/readme-terminal.png" />
</figure>
<p>创建页面已经提供了默认配置，直接点击右上角的<strong>部署</strong>：</p>
<figure class="screenshot">
  <img alt="form-terminal" src="app/../assets/app/form-terminal.png" />
</figure>
<p>等待创建成功的 Terminal 应用就绪：</p>
<figure class="screenshot">
  <img alt="wait-for-terminal" src="app/../assets/app/wait-for-terminal.png" />
</figure>
<p>待应用就绪后，点击右侧的 <span class="twemoji"><svg class="MuiSvgIcon-root MuiSvgIcon-colorPrimary MuiSvgIcon-fontSizeMedium css-jxtyyz" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="OpenInNewIcon"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"></path></svg></span>，即可使用该应用：</p>
<figure class="screenshot">
  <img alt="ui-terminal" src="app/../assets/app/ui-terminal.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署-filebrowser"><a class="header" href="#部署-filebrowser">部署 FileBrowser</a></h1>
<p>FileBrowser 在指定目录中提供了一个文件管理 UI，可用于上传、删除、预览、重命名和编辑文件。本教程演示部署 FileBrowser 应用。</p>
<p>点击 <strong>FileBrowser</strong> 应用，进入 App 详情页面：</p>
<figure class="screenshot">
  <img alt="select-filebrowser" src="app/../assets/app/select-filebrowser.png" />
</figure>
<p>在 App 详情页面，你可以看到如何配置 FileBrowser，这包含了示例 YAML 及参数说明。确认信息后，点击右上角的<strong>立刻部署</strong>进入创建页面：</p>
<figure class="screenshot">
  <img alt="readme-filebrowser" src="app/../assets/app/readme-filebrowser.png" />
</figure>
<p>通过<strong>表单</strong>配置 FileBrowser。为 <code>spec.storageName</code> 字段赋值 <code>demo</code>，即之前创建的存储卷的名称。然后点击右上角的<strong>部署</strong>：</p>
<figure class="screenshot">
  <img alt="form-filebrowser" src="app/../assets/app/form-filebrowser.png" />
</figure>
<p>等待创建成功的 FileBrowser 应用就绪：</p>
<figure class="screenshot">
  <img alt="wait-for-filebrowser" src="app/../assets/app/wait-for-filebrowser.png" />
</figure>
<p>应用就绪后，点击右侧的 <span class="twemoji"><svg class="MuiSvgIcon-root MuiSvgIcon-colorPrimary MuiSvgIcon-fontSizeMedium css-jxtyyz" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="OpenInNewIcon"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"></path></svg></span>，即可使用该应用：</p>
<figure class="screenshot">
  <img alt="ui-filebrowser" src="app/../assets/app/ui-filebrowser.png" />
</figure>
<h2 id="下一步-5"><a class="header" href="#下一步-5">下一步</a></h2>
<ul>
<li>学习如何<a href="app/../task/upload-and-download-file.html">上传和下载文件</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署-codeserver"><a class="header" href="#部署-codeserver">部署 CodeServer</a></h1>
<p>CodeServer 是一个可以通过浏览器访问的 VSCode 服务。本教程演示部署 CodeServer 应用。</p>
<p>点击 <strong>CodeServer</strong> 应用，进入 App 详情页面：</p>
<figure class="screenshot">
  <img alt="select-codeserver" src="app/../assets/app/select-codeserver.png" />
</figure>
<p>在 App 详情页面，你可以看到如何配置 CodeServer，这包含了示例 YAML 及参数说明。确认信息后，点击右上角的<strong>立刻部署</strong>进入创建页面：</p>
<figure class="screenshot">
  <img alt="readme-codeserver" src="app/../assets/app/readme-codeserver.png" />
</figure>
<p>通过<strong>表单</strong>配置 CodeServer。为 <code>spec.storageName</code> 字段赋值 <code>demo</code>，即之前创建的存储卷的名称。然后点击右上角的<strong>部署</strong>：</p>
<figure class="screenshot">
  <img alt="readme-codeserver" src="app/../assets/app/form-codeserver.png" />
</figure>
<p>等待创建成功的 CodeServer 应用就绪：</p>
<figure class="screenshot">
  <img alt="wait-for-codeserver" src="app/../assets/app/wait-for-codeserver.png" />
</figure>
<p>应用就绪后，点击右侧的 <span class="twemoji"><svg class="MuiSvgIcon-root MuiSvgIcon-colorPrimary MuiSvgIcon-fontSizeMedium css-jxtyyz" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="OpenInNewIcon"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"></path></svg></span>，即可使用该应用：</p>
<figure class="screenshot">
  <img alt="ui-codeserver" src="app/../assets/app/ui-codeserver.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署-tensorboard"><a class="header" href="#部署-tensorboard">部署 TensorBoard</a></h1>
<p>TensorBoard 是 TensorFlow 的可视化工具，它可以展示你的 TensorFlow 网络模型（以及其他框架的模型）运行过程中的各种可视化数据。本教程演示部署 TensorBoard 应用。</p>
<p>点击 <strong>TensorBoard</strong> 应用，进入 App 详情页面：</p>
<figure class="screenshot">
  <img alt="select-tensorboard" src="app/../assets/app/select-tensorboard.png" />
</figure>
<p>在 App 详情页面，你可以看到如何配置 TensorBoard，这包含了示例 YAML 及参数说明。确认信息后，点击右上角的<strong>立刻部署</strong>进入创建页面：</p>
<figure class="screenshot">
  <img alt="readme-tensorboard" src="app/../assets/app/readme-tensorboard.png" />
</figure>
<p>通过<strong>表单</strong>配置 TensorBoard，然后点击右上角的<strong>部署</strong>：</p>
<figure class="screenshot">
  <img alt="form-tensorboard" src="app/../assets/app/form-tensorboard.png" />
</figure>
<p>等待创建成功的 TensorBoard 应用就绪：</p>
<figure class="screenshot">
  <img alt="wait-for-tensorboard" src="app/../assets/app/wait-for-tensorboard.png" />
</figure>
<p>应用就绪后，点击右侧的 <span class="twemoji"><svg class="MuiSvgIcon-root MuiSvgIcon-colorPrimary MuiSvgIcon-fontSizeMedium css-jxtyyz" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="OpenInNewIcon"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"></path></svg></span>，即可使用该应用：</p>
<figure class="screenshot">
  <img alt="ui-tensorboard" src="app/../assets/app/ui-tensorboard.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署-job-manager"><a class="header" href="#部署-job-manager">部署 Job Manager</a></h1>
<p>Job Manager 是一个用于管理 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/jobs/index.html">Job</a> 的控制台，可执行创建 Job、查看 Job 状态、监控 Job 事件等操作。</p>
<p>点击 <strong>Job Manager</strong> 应用，进入 App 详情页面：</p>
<figure class="screenshot">
  <img alt="select-job-manager" src="app/../assets/app/select-job-manager.png" />
</figure>
<p>在 App 详情页面，你可以看到如何配置应用，这包含了示例 YAML 和参数说明。确认信息后，点击右上角的<strong>立刻部署</strong>进入创建页面：</p>
<figure class="screenshot">
  <img alt="readme-job-manager" src="app/../assets/app/readme-job-manager.png" />
</figure>
<p>Job Manager 的可配置参数较多，因此没有通过<strong>表单</strong>配置的选项。<strong>YAML 编辑器</strong>中已经预设了一组可用的值，你可以直接使用预设值部署。然后点击右上角的<strong>部署</strong>：</p>
<figure class="screenshot">
  <img alt="yaml-job-manager" src="app/../assets/app/yaml-job-manager.png" />
</figure>
<p>等待创建成功的 Job Manager 应用就绪：</p>
<figure class="screenshot">
  <img alt="wait-for-job-manager" src="app/../assets/app/wait-for-job-manager.png" />
</figure>
<p>应用就绪后，点击右侧的 <span class="twemoji"><svg class="MuiSvgIcon-root MuiSvgIcon-colorPrimary MuiSvgIcon-fontSizeMedium css-jxtyyz" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="OpenInNewIcon"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"></path></svg></span>，即可使用该应用：</p>
<figure class="screenshot">
  <img alt="ui-job-manager" src="app/../assets/app/ui-job-manager.png" />
</figure>
<h2 id="下一步-6"><a class="header" href="#下一步-6">下一步</a></h2>
<ul>
<li>了解 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/jobs/index.html">Job 的定义</a></li>
<li>使用 Job <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/tasks/model-training.html">运行模型训练</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署-postgresql"><a class="header" href="#部署-postgresql">部署 PostgreSQL</a></h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://www.postgresql.org/">PostgreSQL</a> 是一个开源对象关系数据库，以可靠性和数据完整性而闻名。本教程演示部署一个 PostgreSQL 应用。</p>
<p>点击 <strong>PostgreSQL</strong> 应用，进入 App 详情页面：</p>
<figure class="screenshot">
  <img alt="select-postgresql" src="app/../assets/app/select-postgresql.png" />
</figure>
<p>查看 PostgreSQL 的说明：</p>
<figure class="screenshot">
  <img alt="readme-postgresql" src="app/../assets/app/readme-postgresql.png" />
</figure>
<p>向下浏览，可以找到 <strong>Parameters</strong> 标题，这里提供了各个参数的含义。确认信息后，点击右上角<strong>立刻部署</strong>进入部署页面：</p>
<figure class="screenshot">
  <img alt="parameter-postgresql" src="app/../assets/app/parameter-postgresql.png" />
</figure>
<p>结合实际情况和 <strong>README</strong> 中的说明，通过<strong>表单</strong>或者 <strong>YAML 编辑器</strong>配置参数。我们采用默认设置进行安装，仅设置变量 <code>global.postgresql.auth.postgresPassword</code> 即可。然后点击右上角的<strong>部署</strong>：</p>
<figure class="screenshot">
  <img alt="yaml-postgresql" src="app/../assets/app/yaml-postgresql.png" />
</figure>
<p>等待创建成功的 PostgreSQL 应用就绪：</p>
<figure class="screenshot">
  <img alt="wait-for-postgresql" src="app/../assets/app/wait-for-postgresql.png" />
</figure>
<p>PostgreSQL 应用没有 UI，因此无法直接通过链接访问。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="网络服务"><a class="header" href="#网络服务">网络服务</a></h1>
<p>网络服务负责为应用提供平台内外的访问方式。它包括 Service 和 Ingress 两种资源。Service 用于管理平台内部的网络通信，确保不同应用之间能够相互访问和交互；Ingress 则负责管理从平台外部到内部应用的访问路由，使得外部用户或系统能够安全地访问平台内的服务。</p>
<p>基于这些网络服务，用户能够灵活配置应用的网络连接，无论是内部微服务之间的通信，还是对外暴露 API 接口，都能得到有效支持，从而满足 AI 开发和部署过程中复杂多样的网络需求。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="查看-service"><a class="header" href="#查看-service">查看 Service</a></h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">Service</a> 是将运行在一个或一组 Pod 上的网络应用程序公开为网络服务的方法。大部分应用在部署时会自动创建相应的 Service，以方便集群中的其他服务进行访问。</p>
<p>点击<strong>网络服务 &gt; Service</strong>，查看已有的 Service：</p>
<figure class="screenshot">
  <img alt="list-service" src="network/../assets/network/list-service.png" />
</figure>
<p>例如，部署 PostgreSQL 应用时，会自动创建以下 Service：</p>
<figure class="screenshot">
  <img alt="create-service" src="network/../assets/network/create-service.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="查看-ingress"><a class="header" href="#查看-ingress">查看 Ingress</a></h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">Ingress</a> 提供从集群外部到集群内服务的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源所定义的规则来控制。</p>
<p>点击<strong>网络服务 &gt; Ingress</strong>，查看已有的 Ingress：</p>
<figure class="screenshot">
  <img alt="list-ingress" src="network/../assets/network/list-ingress.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="辅助资源"><a class="header" href="#辅助资源">辅助资源</a></h1>
<p>辅助资源负责为应用提供其他支持，例如提供配置数据等。它包括 Secret 和 ConfigMap 两种资源。Secret 用于安全地管理敏感信息，如数据库密码、API 密钥或证书等，确保这些关键信息不会被明文存储或意外暴露。ConfigMap 则用于存储和管理非敏感的配置数据，如环境变量、命令行参数或配置文件等。</p>
<p>通过这两种辅助资源，用户能够灵活地管理应用所需的各种配置信息，既保证了敏感数据的安全性，又提高了配置管理的效率和灵活性。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="创建-secret"><a class="header" href="#创建-secret">创建 Secret</a></h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/auxiliary/secret.html">Secret</a> 是一种 Kubernetes 原生资源，用于存储少量敏感信息，比如密码、OAuth 令牌、SSH 密钥等。使用 Secret 可以避免将敏感数据直接写入到 Pod 的定义中或者应用程序代码里，从而提高了安全性。</p>
<h2 id="ceph-client-类型"><a class="header" href="#ceph-client-类型">Ceph Client 类型</a></h2>
<p>本章演示创建一个 Ceph 客户端的 Secret。在开始之前，你需要从管理员处获取 Ceph Client 的 userID 和 userKey。</p>
<p>点击<strong>辅助 &gt; Secret</strong>，查看已有的 Secret：</p>
<figure class="screenshot">
  <img alt="list-secret" src="auxiliary/../assets/auxiliary/list-secret.png" />
</figure>
<p>点击右上角的创建，进入创建页面，并选择模板为 <strong>Ceph Client</strong>：</p>
<figure class="screenshot">
  <img alt="create-secret-ceph-1" src="auxiliary/../assets/auxiliary/create-secret-ceph-1.png" />
</figure>
<p>填写名称、userID 和 userKey，点击创建即可完成 Secret 的创建：</p>
<figure class="screenshot">
  <img alt="create-secret-ceph-2" src="auxiliary/../assets/auxiliary/create-secret-ceph-2.png" />
</figure>
<h2 id="s3-cfg-类型"><a class="header" href="#s3-cfg-类型">S3-cfg 类型</a></h2>
<p>本章演示创建一个 S3-cfg 类型的 Secret。在开始之前，你需要获取可用的 S3 配置文件，其来源可以是集群管理员或第三方的 S3 服务供应商。</p>
<p>点击<strong>辅助 &gt; Secret</strong>，然后点击右上角的创建，进入创建页面，并选择模板为 <strong>S3-cfg</strong>：</p>
<figure class="screenshot">
  <img alt="create-secret-s3cfg-1" src="auxiliary/../assets/auxiliary/created-secret-s3cfg-1.png" />
</figure>
<p>首先修改资源的“名称”，然后查看“数据 &gt; .s3cfg” 中的内容。这里已经提前写好了一个 S3 配置文件的模板，在此基础上修改 <code>host_base</code>，<code>host_bucket</code>，<code>access_key</code>，<code>secret_key</code> 四个字段的值，或者直接使用 S3 配置文件覆盖其中所有内容：</p>
<figure class="screenshot">
  <img alt="create-secret-s3cfg-2" src="auxiliary/../assets/auxiliary/created-secret-s3cfg-2.png" />
</figure>
<p>点击右上角的创建即可完成 Secret 的创建。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="创建-configmap"><a class="header" href="#创建-configmap">创建 ConfigMap</a></h1>
<p><a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/auxiliary/configmap.html">ConfigMap</a> 是一种 API 对象，用来将非机密性的数据保存到键值对中。本章演示创建 ConfigMap 来保存 Ceph 服务的信息。</p>
<aside class="note">
<div class="title">注意</div>
<p>本章的示例是用户创建一个保存了 Ceph 配置信息的 ConfigMap 作为自己的私有配置。在实际使用中，也可以让管理员创建一个 ConfigMap 作为所有用户的公共配置。</p>
</aside>
<p>点击<strong>辅助 &gt; ConfigMap</strong>，查看已有的 ConfigMap：</p>
<figure class="screenshot">
  <img alt="list-configmap" src="auxiliary/../assets/auxiliary/list-configmap.png" />
</figure>
<p>点击右上角的<strong>创建</strong>，进入创建页面。填写 ConfigMap 名称、标签和数据（这些数据的值来自于管理员），点击右上角的<strong>创建</strong>，即可完成 ConfigMap 的创建：</p>
<figure class="screenshot">
  <img alt="create-configmap" src="auxiliary/../assets/auxiliary/create-configmap.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="账户设置"><a class="header" href="#账户设置">账户设置</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="查看账户信息"><a class="header" href="#查看账户信息">查看账户信息</a></h1>
<p>点击左侧的<strong>账户设置 &gt; 账户信息</strong>，展示了用户的信息：</p>
<figure class="screenshot">
  <img alt="profile" src="account/../assets/account/profile.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="项目管理"><a class="header" href="#项目管理">项目管理</a></h1>
<p>点击左侧的<strong>账户设置 &gt; 项目管理</strong>，展示了当前用户有权限访问的项目：</p>
<figure class="screenshot">
  <img alt="project-management" src="account/../assets/account/project-management.png" width="80%" />
</figure>
<p>在<strong>我的项目</strong>部分，展示的都是当前用户作为项目管理员的项目。这些项目产生的所有费用，都将结算到当前用户的账单中。而在<strong>分享给我的项目</strong>部分展示的项目中，当前用户是项目的普通成员，不需要承担项目的费用。</p>
<p>点击项目名称，可以查看项目的管理员和成员。如果当前用户是项目管理员，还可以点击<strong>成员</strong>右侧的编辑按键调整项目成员：</p>
<figure class="screenshot">
  <img alt="view-member" src="account/../assets/account/view-member.png" />
</figure>
<p>点击<strong>成员</strong>右侧的加号，添加用户或者用户组为项目成员；点击已有成员右侧的减号，可以将该用户或者用户组移除项目成员：</p>
<figure class="screenshot">
  <img alt="edit-member" src="account/../assets/account/edit-member.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="安全设置"><a class="header" href="#安全设置">安全设置</a></h1>
<p>点击左侧的<strong>账户设置 &gt; 安全设置</strong>，进入安全设置页面：</p>
<figure class="screenshot">
  <img alt="security-setting" src="account/../assets/account/security-setting.png" />
</figure>
<p>安全设置页面提供了两个功能，修改密码和管理 API Key。这里我们只演示管理 API Key。</p>
<p>初次使用时，需要点击<strong>管理 API Key</strong> 的<strong>启用</strong>，输入密码来开启 API Key 功能。然后，点击<strong>生成 APIKey</strong> 进入创建页面：</p>
<figure class="screenshot">
  <img alt="create-api-key-1" src="account/../assets/account/create-api-key-1.png" />
</figure>
<p>在创建页面，输入 APIKey 的名称，并勾选该 API Key 的权限。点击下面的<strong>生成 APIKey</strong>完成创建：</p>
<figure class="screenshot">
  <img alt="create-api-key-2" src="account/../assets/account/create-api-key-2.png" />
</figure>
<p>创建完成后，可以复制 API Key 的值：</p>
<figure class="screenshot">
  <img alt="create-api-key-3" src="account/../assets/account/create-api-key-3.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="查看账单"><a class="header" href="#查看账单">查看账单</a></h1>
<p>点击左侧的<strong>账户设置 &gt; 账单</strong>，可以查看账单页面：</p>
<figure class="screenshot">
  <img alt="bill" src="account/../assets/account/bill.png" />
</figure>
<p><strong>账单</strong>显示了当前用户拥有的所有项目的各类费用总和。这些费用来源于你拥有的项目中使用的各种资源，包括计算资源（例如 CPU、GPU、内存）、存储资源（例如 PVC）和网络资源（例如流量）。注意：项目中所有资源的费用都由项目管理员负责，即使这个资源是其他项目成员创建的。</p>
<p><strong>费用详情</strong>列出了费用的细分条目，即每一种资源产生的具体费用。如果你想了解某一种资源的计费方式，可以将鼠标放在该资源右侧的 感叹号 上：</p>
<figure class="screenshot">
  <img alt="billing-practices" src="account/../assets/account/billing-practices.png" />
</figure>
<p>点击<strong>下载当前表格</strong>，可以下载一个包含了<strong>费用详情</strong>信息的 csv 文件。</p>
<p>点击<strong>查看当前价格</strong>，可以查看每种资源的单价：</p>
<figure class="screenshot">
  <img alt="price" src="account/../assets/account/price.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="告警通知"><a class="header" href="#告警通知">告警通知</a></h1>
<p>点击左侧的<strong>账户设置 &gt; 告警通知</strong>，可以查看告警信息。你也可以通过点击上方白色导航栏的右侧的<span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 21h4c0 1.1-.9 2-2 2s-2-.9-2-2m11-2v1H3v-1l2-2v-6c0-3.1 2-5.8 5-6.7V4c0-1.1.9-2 2-2s2 .9 2 2v.3c3 .9 5 3.6 5 6.7v6l2 2m-4-8c0-2.8-2.2-5-5-5s-5 2.2-5 5v7h10v-7Z"/></svg></span>跳转到这个页面：</p>
<figure class="screenshot">
  <img alt="alert" src="account/../assets/account/alert.png" />
</figure>
<p>展开告警信息，可以看到更详细的说明。包括告警信息的开始时间、状态、标签、注释：</p>
<figure class="screenshot">
  <img alt="alert-detailed" src="account/../assets/account/alert-detailed.png" />
</figure>
<p>点击上方的<strong>通知</strong>标签页，填写接收通知的邮箱地址，然后可以设置告警信息的订阅状态：</p>
<figure class="screenshot">
  <img alt="subscribe-alert" src="account/../assets/account/subscribe-alert.png" />
</figure>
<p>订阅你关心的告警信息。被订阅的告警信息触发后，TensorStack AI 平台会发送邮件到指定的邮箱地址：</p>
<figure class="screenshot">
  <img alt="subscribed-alert" src="account/../assets/account/subscribed-alert.png" />
</figure>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="任务"><a class="header" href="#任务">任务</a></h1>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="上传和下载文件"><a class="header" href="#上传和下载文件">上传和下载文件</a></h1>
<p>通过 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/storage/pvc.html">PVC</a> 使用集群存储非常方便，它可以作为存储卷被挂载到 Jupyter Lab 应用、Job、MLService 等各种工作负载的 Pod 中。例如在进行模型训练时，你可以把训练脚本以及训练数据存放到 PVC，然后挂载在 Job 的 Pod 中。</p>
<p>本教程将分场景介绍从集群外部下载/上传文件到 PVC，以及从 PVC 上传/下载文件到集群外部的若干方法。</p>
<p>由于下面的方法需要使用到一些命令行工具或 Python 库，而 <a href="task/../app/jupyter-lab.html">Jupyter Lab 应用</a>提供了终端并且预装了这些命令行工具和 Python 库，因此我们推荐创建一个 Jupyter Lab 应用挂载 PVC，然后在其终端中进行操作。</p>
<aside class="note tip">
<div class="title">提示</div>
<p>对于使用命令行工具 <code>wget</code>（或 <code>curl</code>）、<code>git</code> 或 <code>kubectl</code> 的方法，也可以在 <a href="task/../app/terminal.html">Terminal 应用</a>中进行操作。</p>
</aside>
<aside class="note tip">
<div class="title">提示</div>
<p>Ceph 类型的 PVC 可以扩容，即增加存储卷大小。因此你在创建该类型的 PVC 时可以先指定一个较为保守的存储卷大小的值，之后如有需要则继续增加。</p>
<p>NFS 类型的 PVC 不可扩容。</p>
</aside>
<h2 id="准备工作"><a class="header" href="#准备工作">准备工作</a></h2>
<ul>
<li>完成教程<a href="task/../app/jupyter-lab.html">部署 Jupyter Lab</a>、<a href="task/../app/terminal.html">部署 Terminal</a> 和<a href="task/../app/filebrowser.html">部署 FileBrowser</a></li>
<li>了解 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/auxiliary/datacube.html">DataCube 的概念</a></li>
</ul>
<h2 id="本地文件系统"><a class="header" href="#本地文件系统">本地文件系统</a></h2>
<aside class="note">
<div class="title">注意</div>
<p>在<a href="task/upload-and-download-file.html#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">这一部分</a>，PVC <strong>导入</strong>文件称为<strong>上传</strong>，<strong>导出</strong>文件称为<strong>下载</strong>。在本教程的其余部分则相反，PVC <strong>导入</strong>文件称为<strong>下载</strong>，<strong>导出</strong>文件称为<strong>上传</strong>。</p>
</aside>
<h3 id="jupyter-lab-应用-ui"><a class="header" href="#jupyter-lab-应用-ui">Jupyter Lab 应用 UI</a></h3>
<p>将 PVC 挂载到 <a href="task/../app/jupyter-lab.html">Jupyter Lab 应用</a>上，本地文件系统和 PVC 之间的文件上传下载可以直接在 UI 中进行操作：</p>
<figure class="screenshot">
  <img alt="notebook-upload-download" src="task/../assets/task/upload-and-download-file/notebook-upload-download.png" />
</figure>
<h3 id="filebrowser-应用-ui"><a class="header" href="#filebrowser-应用-ui">FileBrowser 应用 UI</a></h3>
<p>将 PVC 挂载到 <a href="task/../app/filebrowser.html">FileBrowser 应用</a>上，本地文件系统和 PVC 之间的文件上传下载可以直接在 UI 中进行操作：</p>
<figure class="screenshot">
  <img alt="file-browser-upload-download" src="task/../assets/task/upload-and-download-file/file-browser-upload-download.png" />
</figure>
<aside class="note">
<div class="title">注意</div>
<ul>
<li>Jupyter Lab 应用不限制上传或下载的单个文件的大小（根据管理员配置，FileBrowser 有可能限制上传的单个文件的大小）；但上传过程容易因为网络波动而出错，建议 &gt; ~5GB（也取决于具体网络环境）的单个文件使用其他方法上传。</li>
<li>可以一次上传或下载多个文件；但在文件数量较多（&gt; ~50）的情况下容易出错，推荐打包成压缩文件再上传或下载。</li>
</ul>
</aside>
<h3 id="云存储中转"><a class="header" href="#云存储中转">云存储中转</a></h3>
<p>也可以通过其他云存储服务进行中转，即<strong>本地 → 云存储 → PVC</strong>：</p>
<ol>
<li>本地与云存储之间的文件传输方法请参阅相应云存储的文档；</li>
<li>云存储与 PVC 之间的文件传输方法请参阅<a href="task/upload-and-download-file.html#%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1">云存储服务</a>。</li>
</ol>
<h2 id="云存储服务"><a class="header" href="#云存储服务">云存储服务</a></h2>
<h3 id="rclone-命令"><a class="header" href="#rclone-命令"><code>rclone</code> 命令</a></h3>
<p>要在云存储与 PVC 之间复制或同步文件，可以使用命令行工具 <a target="_blank" rel="noopener noreferrer" href="https://rclone.org">rclone</a>。这里以 Amazon S3 为例，首先参照 <a target="_blank" rel="noopener noreferrer" href="https://rclone.org/s3/">Amazon S3 Config</a> 进行配置，完成后执行以下命令：</p>
<pre><code class="language-bash">rclone copy &lt;REMOTE&gt;:&lt;BUCKET&gt;/path/to/the/file .   # 从 S3 存储下载
rclone copy ./file &lt;REMOTE&gt;:&lt;BUCKET&gt;/path/to/the/  # 上传到 S3 存储

rclone sync &lt;REMOTE&gt;:&lt;BUCKET&gt;/path/to/the/dir .    # 从 S3 存储同步
rclone sync . &lt;REMOTE&gt;:&lt;BUCKET&gt;/path/to/the/dir    # 同步到 S3 存储
</code></pre>
<aside class="note info">
<div class="title">信息</div>
<p>rclone 支持的云存储提供商请参阅 <a target="_blank" rel="noopener noreferrer" href="https://rclone.org/#providers">Supported Providers</a>。</p>
</aside>
<p>对于 Amazon S3，除了 rclone 之外还有其他命令行工具可供使用，例如 <a target="_blank" rel="noopener noreferrer" href="https://github.com/s3tools/s3cmd">s3cmd</a>、<a target="_blank" rel="noopener noreferrer" href="https://github.com/peak/s5cmd">s5cmd</a> 等。</p>
<h3 id="datacube"><a class="header" href="#datacube">DataCube</a></h3>
<p>对于 Amazon S3 也可以使用平台提供的 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/auxiliary/datacube.html#s3">DataCube</a>。使用以下 YAML 配置文件创建 DataCube（修改 PVC 名称、PVC 路径、Secret 名称和 S3 URL）以下载和上传文件：</p>
<details><summary><code class="hljs">download-s3.yaml</code></summary>
<pre><code class="language-yaml">apiVersion: tensorstack.dev/v1beta1
kind: DataCube
metadata:
  name: download-s3
spec:
  source:
    type: s3
    options:
    - name: s3-endpoint
      valueFrom:
        secretKeyRef:
          name: &lt;S3ENV_SECRET_NAME&gt;  # s3-env 类型的 Secret
          key: endpoint
    - name: s3-access-key-id
      valueFrom:
        secretKeyRef:
          name: &lt;S3ENV_SECRET_NAME&gt;
          key: accessKeyID
    - name: s3-secret-access-key
      valueFrom:
        secretKeyRef:
          name: &lt;S3ENV_SECRET_NAME&gt;
          key: secretAccessKey
    - name: s3-uri
      value: s3://&lt;BUCKET&gt;/path/to/the/dir   # 下载目录下的所有子目录和文件
      # value: s3://&lt;BUCKET&gt;/path/to/the/file  # 下载文件
  sink: 
    type: pvc
    pvc:
      name: &lt;PVC_NAME&gt;
      subPath: save/path
  # executor:
  #   options:
  #     sync: true  # 完全同步，会删除多余的文件
</code></pre>
</details>
<details><summary><code class="hljs">upload-s3.yaml</code></summary>
<pre><code class="language-yaml">apiVersion: tensorstack.dev/v1beta1
kind: DataCube
metadata:
  name: upload-s3
spec:
  source:
    type: pvc
    pvc:
      name: &lt;PVC_NAME&gt;
      subPath: path/to/the/dir        # 上传目录下的所有子目录和文件
      # subPath: path/to/the/file     # 上传文件
  sink: 
    type: s3
    options:
    - name: s3-endpoint
      valueFrom:
        secretKeyRef:
          name: &lt;S3ENV_SECRET_NAME&gt;   # s3-env 类型的 Secret
          key: endpoint
    - name: s3-access-key-id
      valueFrom:
        secretKeyRef:
          name: &lt;S3ENV_SECRET_NAME&gt;
          key: accessKeyID
    - name: s3-secret-access-key
      valueFrom:
        secretKeyRef:
          name: &lt;S3ENV_SECRET_NAME&gt;
          key: secretAccessKey
    - name: s3-uri
      value: s3://&lt;BUCKET&gt;/save/path  # 目标 S3 路径
</code></pre>
</details>
<pre><code class="language-bash">kubectl create -f download-s3.yaml
kubectl create -f upload-s3.yaml
</code></pre>
<h2 id="httpftp-服务"><a class="header" href="#httpftp-服务">HTTP/FTP 服务</a></h2>
<h3 id="wget-命令"><a class="header" href="#wget-命令">wget 命令</a></h3>
<p>要通过 HTTP(S)、(S)FTP 等协议从网络下载文件到 PVC，可以在终端中使用 <code>wget</code>（或 <code>curl</code>）命令进行下载：</p>
<pre><code class="language-bash">wget &lt;URL&gt;

# 或

curl -O &lt;URL&gt;
</code></pre>
<aside class="note tip">
<div class="title">提示</div>
<p>你也可以在终端中使用命令行工具 rclone 来访问和下载存储在 HTTP(S) 和 FTP(S) 服务器上的文件（对于 FTP(S) 服务器还可以上传文件）。rclone 将这些服务器视为一种类型的云存储，请参阅 <a target="_blank" rel="noopener noreferrer" href="https://rclone.org/http/">HTTP Config</a> 和 <a target="_blank" rel="noopener noreferrer" href="https://rclone.org/ftp/">FTP Config</a>。</p>
</aside>
<h2 id="git-仓库"><a class="header" href="#git-仓库">Git 仓库</a></h2>
<h3 id="git-命令"><a class="header" href="#git-命令"><code>git</code> 命令</a></h3>
<p>可以在终端中使用 <code>git</code> 命令，从 GitHub 等代码托管平台克隆或拉取 Git 仓库，并在提交修改后推送回去：</p>
<pre><code class="language-bash">git clone &lt;REPO_URL&gt;
git pull
git fetch
git push
</code></pre>
<h3 id="datacube-1"><a class="header" href="#datacube-1">DataCube</a></h3>
<p>也可以使用平台提供的 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/auxiliary/datacube.html#git">DataCube</a>。使用以下 YAML 配置文件创建 DataCube（修改 PVC 名称、PVC 路径、Secret 名称和 S3 URL）以克隆（或拉取）和推送提交到 Git 仓库：</p>
<details><summary><code class="hljs">download-git.yaml</code></summary>
<pre><code class="language-yaml">apiVersion: tensorstack.dev/v1beta1
kind: DataCube
metadata:
  name: download-git
spec:
  source:
    type: git
    options:
    # - name: token  # 个人访问令牌
    #   valueFrom:
    #     secretKeyRef:
    #       name: &lt;CUSTOM_SECRET_NAME&gt;  # custom 类型的 Secret
    #       key: token                  # 引用键 token 的值
    - name: url
      value: &lt;GIT_REPO_URL&gt;       # 克隆（或拉取）的 Git 仓库
      # value: https://$(TOKEN)@github.com/&lt;OWNER&gt;/&lt;REPO_NAME&gt;.git  # GitHub 仓库
    - name: ref
      value: &lt;BRANCH_TAG_OR_COMMIT&gt;     # 切换到此 ref
  sink: 
    type: pvc
    pvc:
      name: &lt;PVC_NAME&gt;
      subPath: save/path
</code></pre>
</details>
<details><summary><code class="hljs">upload-git.yaml</code></summary>
<pre><code class="language-yaml">apiVersion: tensorstack.dev/v1beta1
kind: DataCube
metadata:
  name: upload-git
spec:
  source:
    type: pvc
    pvc:
      name: &lt;PVC_NAME&gt;
      subPath: path/to/the/parent/dir  # 若目标 Git 仓库为 https://github.com/owner/repo.git，
  sink:                                # 则推送的本地 Git 仓库为 path/to/the/parent/dir/repo
    type: git
    options:
    - name: token  # 个人访问令牌
      valueFrom:
        secretKeyRef:
          name: &lt;CUSTOM_SECRET_NAME&gt;   # custom 类型的 Secret
          key: token                   # 引用键 token 的值
    - name: url
      value: &lt;GIT_REPO_URL&gt;      # 目标 Git 仓库
      # value: https://$(TOKEN)@github.com/&lt;OWNER&gt;/&lt;REPO_NAME&gt;.git  # GitHub 仓库
</code></pre>
</details>
<pre><code class="language-bash">kubectl create -f download-git.yaml
kubectl create -f upload-git.yaml
</code></pre>
<h2 id="hugging-face"><a class="header" href="#hugging-face">Hugging Face</a></h2>
<p><a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/">Hugging Face</a> 是一个 AI 开源社区，其提供的 Git 仓库托管了大量流行的开源模型和数据集。</p>
<p>这里介绍从 Hugging Face 下载模型文件到 PVC（以模型 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/facebook/opt-125m"><code>facebook/opt-125m</code></a> 为例），以及从 PVC 上传模型文件到 Hugging Face（以用户自己创建的模型 <code>user/llm</code> 为例）的若干方法。数据集类似。</p>
<h3 id="git-命令-1"><a class="header" href="#git-命令-1"><code>git</code> 命令</a></h3>
<p>Hugging Face 模型或数据集本身就是一个 Git 仓库，因此可以参照 <a href="task/upload-and-download-file.html#git-%E4%BB%93%E5%BA%93">Git 仓库</a>的方法。需要注意的是：</p>
<ul>
<li>
<p>Git 仓库的 HTTPS URL 为 <code>https://huggingface.co/&lt;OWNER&gt;/&lt;MODEL_OR_DATASET_NAME&gt;</code>，例如模型 <code>facebook/opt-125m</code> 的 HTTPS URL 为 <code>https://huggingface.co/facebook/opt-125m</code>。</p>
</li>
<li>
<p>Git LFS 被用于管理大于 10MB 的文件（Jupyter Lab 应用已经安装了 Git LFS，并在启动时进行了初始化）。如要推送大于 10MB 的文件，请先通过 Git LFS 追踪该文件：</p>
<pre><code class="language-bash">git lfs track large_file
git add large_file
git commit -m &quot;Add the large file&quot;
git push
</code></pre>
</li>
<li>
<p>如要访问受保护的模型或数据集（例如模型 <code>meta-llama/Meta-Llama-3-8B</code>），访问私有模型或数据集，或推送提交到模型或数据集，则需要提供拥有相应权限的用户的用户名和 token：</p>
<pre><code class="language-bash"># 克隆受保护的模型的 Git 仓库
git clone https://&lt;HF_USERNAME&gt;:&lt;HF_TOKEN&gt;@huggingface.co/meta-llama/Meta-Llama-3-8B

# 克隆私有模型的 Git 仓库
git clone https://&lt;HF_USERNAME&gt;:&lt;HF_TOKEN&gt;@huggingface.co/user/private-llm

# 克隆模型的 Git 仓库并在提交修改后推送回去
git clone https://&lt;HF_USERNAME&gt;:&lt;HF_TOKEN&gt;@huggingface.co/user/llm
git add ...
git commit ...
git push
</code></pre>
</li>
</ul>
<h3 id="transformers-库和-datasets-库"><a class="header" href="#transformers-库和-datasets-库"><code>transformers</code> 库和 <code>datasets</code> 库</a></h3>
<p>可以使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/huggingface/transformers"><code>transformers</code> 库</a>下载和上传模型文件以及 tokenizer 文件。使用浏览器访问模型 <code>facebook/opt-125m</code> 的 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/facebook/opt-125m/tree/main">Files 标签页</a>。点击 <strong>Use in Transformers</strong>，按照提示进行操作，即在 Python 程序中调用 <code>transformers</code> 库加载模型。首次加载时，仓库中的模型文件和 tokenizer 文件会被下载到缓存目录下，即 PVC 的 <code>.cache/huggingface/hub/models--facebook--opt-125m/</code> 路径下。</p>
<figure class="screenshot">
  <img alt="use-in-transformers" src="task/../assets/task/upload-and-download-file/use-in-transformers.png" />
</figure>
<figure class="screenshot">
  <img alt="use-in-transformers-detail" src="task/../assets/task/upload-and-download-file/use-in-transformers-detail.png" />
</figure>
<pre><code class="language-python">from transformers import pipeline
pipe = pipeline(&quot;text-generation&quot;, model=&quot;facebook/opt-125m&quot;)

# 或

from transformers import AutoTokenizer, AutoModelForCausalLM
tokenizer = AutoTokenizer.from_pretrained(&quot;facebook/opt-125m&quot;)
model = AutoModelForCausalLM.from_pretrained(&quot;facebook/opt-125m&quot;)
</code></pre>
<p>对于受保护的或私有的模型（例如模型 <code>meta-llama/Meta-Llama-3-8B</code>），需要提供拥有读权限的用户的 token：</p>
<pre><code class="language-python">from transformers import pipeline
pipe = pipeline(&quot;text-generation&quot;, model=&quot;meta-llama/Meta-Llama-3-8B&quot;, token=&quot;&lt;HF_TOKEN&gt;&quot;)

# 或

from transformers import AutoTokenizer, AutoModelForCausalLM
tokenizer = AutoTokenizer.from_pretrained(&quot;meta-llama/Meta-Llama-3-8B&quot;, token=&quot;&lt;HF_TOKEN&gt;&quot;)
model = AutoModelForCausalLM.from_pretrained(&quot;meta-llama/Meta-Llama-3-8B&quot;, token=&quot;&lt;HF_TOKEN&gt;&quot;)
</code></pre>
<p>使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/huggingface/datasets"><code>datasets</code> 库</a>下载和上传数据集文件。相比加载模型，加载数据集要更加复杂一些，请参阅教程
<a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/datasets/load_hub">Load a dataset</a> 和 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/datasets/loading">Load</a>。</p>
<p>调用<a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/transformers/main_classes/model#transformers.PreTrainedModel">模型对象</a>、<a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizer">tokenizer 对象</a>或<a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/datasets/package_reference/main_classes#datasets.Dataset">数据集对象</a>的 <code>push_to_hub()</code> 方法以将其文件上传到仓库，需要提供拥有写权限的用户的 token：</p>
<pre><code class="language-python">...
model.push_to_hub(&quot;user/llm&quot;, token=&quot;&lt;HF_TOKEN&gt;&quot;)
tokenizer.push_to_hub(&quot;user/llm&quot;, token=&quot;&lt;HF_TOKEN&gt;&quot;)
dataset.push_to_hub(&quot;user/data&quot;, token=&quot;&lt;HF_TOKEN&gt;&quot;)
</code></pre>
<aside class="note info">
<div class="title">信息</div>
<p>对于上传，更详细的教程请参阅 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/transformers/model_sharing">Share a model</a> 和 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/datasets/upload_dataset">Share a dataset</a>。</p>
</aside>
<h3 id="huggingface-cli-命令和-huggingface_hub-库"><a class="header" href="#huggingface-cli-命令和-huggingface_hub-库"><code>huggingface-cli</code> 命令和 <code>huggingface_hub</code> 库</a></h3>
<p>可以使用 <code>huggingface-cli download</code> 命令下载仓库中的所有文件或指定文件：</p>
<pre><code class="language-bash"># 下载所有文件
huggingface-cli download facebook/opt-125m

# 下载单个指定文件
huggingface-cli download facebook/opt-125m pytorch_model.bin

# 下载多个指定文件
huggingface-cli download facebook/opt-125m pytorch_model.bin generation_config.json

# 模式匹配
huggingface-cli download facebook/opt-125m --include=&quot;*.bin&quot;
huggingface-cli download facebook/opt-125m --exclude=&quot;*.bin&quot;

# 指定缓存目录
huggingface-cli download facebook/opt-125m --cache-dir .

# 下载数据集文件
huggingface-cli download cais/mmlu all/test-00000-of-00001.parquet --repo-type=dataset
</code></pre>
<p>可以指定放置下载文件的本地目录，否则文件会被放置到与 <a href="task/upload-and-download-file.html#transformers-%E5%BA%93"><code>transformers</code> 库</a>相同的缓存目录下：</p>
<pre><code class="language-bash"># 文件被放置到缓存目录下
huggingface-cli download facebook/opt-125m

# 文件被放置到指定的本地目录下，其中大于 10MB 的文件会被替换为指向相应缓存文件的符号链接
huggingface-cli download facebook/opt-125m --local-dir &quot;opt-125m&quot;

# 文件被放置到指定的本地目录下
huggingface-cli download facebook/opt-125m --local-dir &quot;opt-125m&quot; --local-dir-use-symlinks False
</code></pre>
<p>对于受保护的或私有的模型或数据集（例如模型 <code>meta-llama/Meta-Llama-3-8B</code>），需要提供拥有读权限的用户的 token：</p>
<pre><code class="language-bash">huggingface-cli login --token &lt;HF_TOKEN&gt;  # 登录到 Hugging Face
huggingface-cli download meta-llama/Meta-Llama-3-8B

# 或

huggingface-cli download meta-llama/Meta-Llama-3-8B --token &lt;HF_TOKEN&gt;
</code></pre>
<p>使用 <code>huggingface-cli upload</code> 命令上传文件或整个目录到仓库，需要提供拥有写权限的用户的 token：</p>
<pre><code class="language-bash"># Usage: huggingface-cli upload &lt;REPO_ID&gt; &lt;LOCAL_PATH&gt; [REPO_PATH]

huggingface-cli login --token &lt;HF_TOKEN&gt;  # 登录到 Hugging Face
huggingface-cli upload user/llm . .                       # 上传整个目录
huggingface-cli upload user/llm ./pytorch_model.bin       # 上传单个指定文件
huggingface-cli upload user/llm . . --exclude=&quot;/logs/*&quot;   # 模式匹配
huggingface-cli upload user/data . . --repo-type=dataset  # 上传数据集文件

# 或

huggingface-cli upload user/llm . . --token &lt;HF_TOKEN&gt;
</code></pre>
<aside class="note info">
<div class="title">信息</div>
<p>更详细的教程请参阅 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/main/en/guides/cli#huggingface-cli-download">huggingface-cli download</a> 和 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/main/en/guides/cli#huggingface-cli-upload">huggingface-cli upload</a>。</p>
</aside>
<p>实际上，<code>huggingface-cli</code> 是 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/index"><code>huggingface_hub</code> 库</a>的命令行工具。<code>huggingface-cli download</code> 命令在内部调用了该库的 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/main/en/package_reference/file_download#huggingface_hub.hf_hub_download"><code>hf_hub_download()</code></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/main/en/package_reference/file_download#huggingface_hub.snapshot_download"><code>snapshot_download()</code></a> 函数，<code>huggingface-cli upload</code> 命令在内部调用了该库的 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/main/en/package_reference/hf_api#huggingface_hub.HfApi.upload_file"><code>upload_file()</code></a> 和 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/main/en/package_reference/hf_api#huggingface_hub.HfApi.upload_folder"><code>upload_folder()</code></a> 函数。我们同样可以在 Python 程序中调用该库的这些函数来下载和上传文件，这里不再展开，请参阅教程 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/main/en/guides/download">Download files</a> 和 <a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/main/en/guides/upload">Upload files</a>。</p>
<h3 id="wget-命令-1"><a class="header" href="#wget-命令-1"><code>wget</code> 命令</a></h3>
<p>如果只需要下载个别文件，那么也可以复制相应文件的下载链接，然后在终端中使用 <code>wget</code>（或 <code>curl</code>）命令下载：</p>
<pre><code class="language-bash">wget https://huggingface.co/facebook/opt-125m/resolve/main/pytorch_model.bin?download=true -O pytorch_model.bin

# 或

curl -L https://huggingface.co/facebook/opt-125m/resolve/main/pytorch_model.bin?download=true -o pytorch_model.bin
</code></pre>
<p>对于受保护的或私有的模型或数据集（例如模型 <code>meta-llama/Meta-Llama-3-8B</code>），需要提供拥有读权限的用户的 token：</p>
<pre><code class="language-bash">wget --header=&quot;Authorization: Bearer &lt;HF_TOKEN&gt;&quot; https://huggingface.co/meta-llama/Meta-Llama-3-8B/resolve/main/model-00001-of-00004.safetensors?download=true -O model-00001-of-00004.safetensors

# 或

curl --header &quot;Authorization: Bearer &lt;HF_TOKEN&gt;&quot; -L https://huggingface.co/meta-llama/Meta-Llama-3-8B/resolve/main/model-00001-of-00004.safetensors?download=true -o model-00001-of-00004.safetensors
</code></pre>
<h3 id="datacube-2"><a class="header" href="#datacube-2">DataCube</a></h3>
<p>也可以使用平台提供的 <a href="task/../modules/auxiliary/datacube.html#hugging-face">DataCube</a>，其在内部调用的就是 <a href="task/upload-and-download-file.html#huggingface-cli-%E5%91%BD%E4%BB%A4%E5%92%8C-huggingface_hub-%E5%BA%93"><code>huggingface-cli</code> 命令</a>。使用以下 YAML 配置文件创建 DataCube（修改 PVC 名称、PVC 路径、Secret 名称和 S3 URL）以下载和上传文件：</p>
<details><summary><code class="hljs">download-hf.yaml</code></summary>
<pre><code class="language-yaml">apiVersion: tensorstack.dev/v1beta1
kind: DataCube
metadata:
  name: download-hf
spec:
  source:
    type: huggingface
    options:
    # - name: token  # Hugging Face token
    #   valueFrom:
    #     secretKeyRef:
    #       name: &lt;CUSTOM_SECRET_NAME&gt;  # custom 类型的 Secret
    #       key: token                  # 引用键 token 的值
    - name: repo
      value: &lt;OWNER&gt;/&lt;MODEL_OR_DATASET_NAME&gt;  # 下载的 Hugging Face 仓库 ID
    # - name: files
    #   value: &lt;FILE1&gt;, &lt;FILE2&gt;, ...          # 下载的文件列表，默认为所有文件
  sink: 
    type: pvc
    pvc:
      name: &lt;PVC_NAME&gt;
      subPath: save/path
  # executor:
  #   env:
  #   - name: HTTPS_PROXY
  #     value: &lt;host&gt;:&lt;port&gt;            # HTTPS 代理
</code></pre>
</details>
<details><summary><code class="hljs">upload-hf.yaml</code></summary>
<pre><code class="language-yaml">apiVersion: tensorstack.dev/v1beta1
kind: DataCube
metadata:
  name: upload-hf
spec:
  source:
    type: pvc
    pvc:
      name: &lt;PVC_NAME&gt;
      subPath: path/to/the/dir         # 上传目录下的所有子目录和文件
      # subPath: path/to/the/file      # 上传文件
  sink:
    type: huggingface
    options:
    - name: token  # Hugging Face token
      valueFrom:
        secretKeyRef:
          name: &lt;CUSTOM_SECRET_NAME&gt;   # custom 类型的 Secret
          key: token                   # 引用键 token 的值
    - name: repo
      value: &lt;OWNER&gt;/&lt;MODEL_OR_DATASET_NAME&gt;  # 上传的 Hugging Face 仓库 ID
    - name: path-in-repo
      value: upload/path               # 目标路径
    - name: commit-message
      value: &lt;COMMIT_MESSAGE&gt;          # 提交消息
  # executor:
  #   env:
  #   - name: HTTPS_PROXY
  #     value: &lt;host&gt;:&lt;port&gt;            # HTTPS 代理
</code></pre>
</details>
<pre><code class="language-bash">kubectl create -f download-hf.yaml
kubectl create -f upload-hf.yaml
</code></pre>
<h2 id="modelscope"><a class="header" href="#modelscope">ModelScope</a></h2>
<p><a target="_blank" rel="noopener noreferrer" href="https://modelscope.cn/">ModelScope</a> 是一个中文 AI 开源社区，可以视作中国版的 Hugging Face。ModelScope 上托管的模型和数据集相比 Hugging Face 要少得多，但对于国内用户，访问 ModelScope 的网络连通性更好。</p>
<p>这里介绍从 ModelScope 下载模型文件到 PVC（以模型 <a target="_blank" rel="noopener noreferrer" href="https://modelscope.cn/models/AI-ModelScope/opt-125/"><code>AI-ModelScope/opt-125</code></a> 为例），以及从 PVC 上传模型文件到 ModelScope（以用户自己创建的模型 <code>user/llm</code> 为例）的若干方法。数据集类似。</p>
<h3 id="git-命令-2"><a class="header" href="#git-命令-2"><code>git</code> 命令</a></h3>
<p>与 <a href="task/upload-and-download-file.html#git-%E5%91%BD%E4%BB%A4-1">Hugging Face</a> 类似，除了：</p>
<ul>
<li>
<p>Git 仓库的 HTTPS URL 为 <code>https://www.modelscope.cn/&lt;OWNER&gt;/&lt;MODEL_OR_DATASET_NAME&gt;.git</code>，例如模型 <code>AI-ModelScope/opt-125</code> 的 HTTPS URL 为 <code>https://www.modelscope.cn/AI-ModelScope/opt-125.git</code>。</p>
</li>
<li>
<p>Git LFS 被用于管理大于 100MB 的文件（Jupyter Lab 应用已经安装了 Git LFS，并在启动时进行了初始化）。如要推送大于 100MB 的文件，请先通过 Git LFS 追踪该文件：</p>
<pre><code class="language-bash">git lfs track large_file
git add large_file
git commit -m &quot;Add the large file&quot;
git push
</code></pre>
</li>
<li>
<p>如要访问受保护的模型或数据集，访问私有模型或数据集，或推送提交到模型或数据集，则需要提供拥有相应权限的用户的 token：</p>
<pre><code class="language-bash"># 克隆私有模型的 Git 仓库
git clone http://oauth2:&lt;MODELSCOPE_TOKEN&gt;@www.modelscope.cn/user/private-llm.git

# 克隆模型的 Git 仓库并在提交修改后推送回去
git clone http://oauth2:&lt;MODELSCOPE_TOKEN&gt;@www.modelscope.cn/user/llm.git
git add ...
git commit ...
git push
</code></pre>
</li>
</ul>
<h3 id="modelscope-库"><a class="header" href="#modelscope-库"><code>modelscope</code> 库</a></h3>
<p>可以使用 <code>modelscope</code> 库下载和上传文件。第一种下载模型文件的方法类似于 <a href="task/upload-and-download-file.html#transformers-%E5%BA%93%E5%92%8C-datasets-%E5%BA%93"><code>transformers</code> 库</a>（在内部也调用了 <code>transformers</code> 库）。首次加载时，仓库中的所有文件会被下载到缓存目录下，即 PVC 的 <code>.cache/modelscope/hub/AI-ModelScope/opt-125/</code> 路径下。</p>
<pre><code class="language-python">from modelscope.models import Model
model = Model.from_pretrained(&quot;AI-ModelScope/opt-125&quot;)
</code></pre>
<p>第二种下载模型文件的方法类似于 <a href="task/upload-and-download-file.html#huggingface-cli-%E5%91%BD%E4%BB%A4%E5%92%8C-huggingface_hub-%E5%BA%93"><code>huggingface_hub</code> 库</a>。文件会被下载到与第一种方法相同的缓存目录下。</p>
<pre><code class="language-python">from modelscope import snapshot_download
from modelscope.hub.file_download import model_file_download

snapshot_download(&quot;AI-ModelScope/opt-125&quot;)                                   # 下载所有文件
model_file_download(&quot;AI-ModelScope/opt-125&quot;, file_path=&quot;pytorch_model.bin&quot;)  # 下载单个指定文件
snapshot_download(&quot;AI-ModelScope/opt-125&quot;, cache_dir=&quot;.&quot;)                    # 指定缓存目录
</code></pre>
<p>第三种下载模型文件的方法类似于 <code>huggingface-cli</code> 命令，可以使用 <code>modelscope download</code> 命令下载仓库中的所有文件或指定文件：</p>
<pre><code class="language-bash"># 下载所有文件
modelscope download --model &quot;AI-ModelScope/opt-125&quot;

# 下载单个指定文件
modelscope download --model &quot;AI-ModelScope/opt-125&quot; pytorch_model.bin

# 下载多个指定文件
modelscope download --model &quot;AI-ModelScope/opt-125&quot; pytorch_model.bin tf_model.h5

# 模式匹配
modelscope download --model &quot;AI-ModelScope/opt-125&quot; --include &quot;*.bin&quot;
modelscope download --model &quot;AI-ModelScope/opt-125&quot; --exclude &quot;*.bin&quot;

# 指定下载目录
modelscope download --model &quot;AI-ModelScope/opt-125&quot; --local_dir &quot;./opt-125m&quot;
</code></pre>
<p>可以指定放置下载文件的本地目录，否则文件会被放置到与第一种方法相同的缓存目录下：</p>
<pre><code class="language-bash"># 文件被放置到缓存目录下
modelscope download --model &quot;AI-ModelScope/opt-125&quot;

# 文件被放置到指定的本地目录下
modelscope download --model &quot;AI-ModelScope/opt-125&quot; --local_dir &quot;./opt-125m&quot;
</code></pre>
<p>下载数据集文件的方法类似于 <a href="task/upload-and-download-file.html#transformers-%E5%BA%93%E5%92%8C-datasets-%E5%BA%93"><code>datasets</code> 库</a>。这里以数据集 MMLU 的子集 Abstract Algebra 为例，注意不同的数据集拥有不同的可用子集。首次加载时，仓库中的数据集文件会被下载到缓存目录下，即 PVC 的 <code>.cache/modelscope/hub/datasets/mmlu/abstract_algebra/</code> 路径下。</p>
<pre><code class="language-python">from modelscope.msdatasets import MsDataset
dataset = MsDataset.load(&quot;mmlu&quot;, subset_name=&quot;abstract_algebra&quot;)
</code></pre>
<p>对于受保护的或私有的模型或数据集，需要提供拥有读权限的用户的 token：</p>
<pre><code class="language-python">from modelscope import HubApi

api=HubApi()
api.login(&quot;&lt;MODELSCOPE_TOKEN&gt;&quot;)  # 登录到 ModelScope

# 然后参照上面的方法下载
</code></pre>
<p>上传模型文件的方法如下所示。<code>modelscope</code> 库暂不支持上传数据集文件。</p>
<pre><code class="language-python">from modelscope.hub.api import HubApi

api = HubApi()
api.login(&quot;&lt;MODELSCOPE_TOKEN&gt;&quot;)  # 登录到 ModelScope

api.push_model(
    model_id=&quot;&lt;OWNER&gt;/&lt;MODEL_NAME&gt;&quot;,
    model_dir=&quot;&lt;LOCAL_PATH&gt;&quot;     # 本地模型目录，要求目录中必须包含 configuration.json
)
</code></pre>
<h2 id="大规模数据"><a class="header" href="#大规模数据">大规模数据</a></h2>
<p>在处理大规模数据（如 100TB 级别）的导入和导出时，根据数据源的不同，我们采用不同的策略以确保数据传输的效率和安全性。以下是针对不同数据源的一些方法：</p>
<p>数据源为云存储时：</p>
<ul>
<li>参照<a href="task/upload-and-download-file.html#%E4%BA%91%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1">云存储服务</a>操作。</li>
</ul>
<p>数据源为 HDD/SDD 外置驱动器或类似设备时：</p>
<ol>
<li>将驱动器连接到集群外的与集群网络连接速度较快的计算机上，然后参照<a href="task/upload-and-download-file.html#%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">本地文件系统</a>继续操作。</li>
<li>或者，请求管理员操作，将驱动器连接到存储集群的节点上，直接使用存储系统的工具进行数据传输。这种方法的数据传输速度一般较快，但需要能够访问存储集群的工具和接口。</li>
</ol>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<ul>
<li><a target="_blank" rel="noopener noreferrer" href="https://rclone.org/">rclone</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://github.com/s3tools/s3cmd">s3cmd</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://github.com/peak/s5cmd">s5cmd</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/">Hugging Face</a>
<ul>
<li><a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/transformers/">Hugging Face Transformers</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/datasets/">Hugging Face Datasets</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://huggingface.co/docs/huggingface_hub/">Hugging Face Hub Python Library</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener noreferrer" href="https://modelscope.cn/">ModelScope</a>
<ul>
<li><a target="_blank" rel="noopener noreferrer" href="https://modelscope.cn/docs">ModelScope 文档中心</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="训练模型"><a class="header" href="#训练模型">训练模型</a></h1>
<p>这一部分的任务围绕深度学习模型的训练展开。通过这些任务，你将能够体验平台在模型训练领域的强大功能，具体包括：</p>
<ol>
<li>使用平台提供的 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/jobs/index.html">Job</a> API，在多种深度学习框架或分布式训练框架下进行并行训练</li>
<li>执行少数几行命令即可简单快速地启动训练任务</li>
<li>通过可视化界面查看训练信息，实时监控训练进程和指标</li>
<li>运用各种并行策略，高效分配计算资源，并且容易扩大规模</li>
<li>使用 Job 的重启机制显著提升训练的故障容错能力</li>
<li>分析性能以识别训练代码中的性能瓶颈和优化机会</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="进行数据并行训练"><a class="header" href="#进行数据并行训练">进行数据并行训练</a></h1>
<p>本教程演示使用 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/jobs/pytorchtrainingjob.html">PyTorchTrainingJob</a> 对 PyTorch 模型进行多工作器同步训练（使用 <a target="_blank" rel="noopener noreferrer" href="https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html"><code>torch.nn.parallel.DistributedDataParallel</code></a> 分布式数据并行模块）。本教程对应示例<a target="_blank" rel="noopener noreferrer" href="https://github.com/t9k/tutorial-examples/tree/master/job/pytorchtrainingjob/ddp">使用 PyTorchTrainingJob 进行数据并行训练</a>。</p>
<p>本教程的应用架构如下图所示：</p>
<figure class="architecture">
  <img alt="app-arch" src="task/train-model/../../assets/task/train-model/dp-training/app-arch.drawio.svg" />
</figure>
<h2 id="运行示例"><a class="header" href="#运行示例">运行示例</a></h2>
<p>创建一个名为 tutorial、大小 1 Gi 的 <a href="task/train-model/../../storage/volume.html">PVC</a>，然后部署一个同样名为 tutorial 的 <a href="task/train-model/../../app/jupyter-lab.html">JupyterLab 应用</a>挂载该 PVC，镜像和资源不限。</p>
<p>进入 JupyterLab，启动一个终端，执行以下命令以克隆 <code>t9k/tutorial-examples</code> 仓库。</p>
<pre><code class="language-bash">cd ~
git clone https://github.com/t9k/tutorial-examples.git
</code></pre>
<p>继续使用 JupyterLab 的终端，前往<a target="_blank" rel="noopener noreferrer" href="https://github.com/t9k/tutorial-examples/tree/master/job/pytorchtrainingjob/ddp">本教程对应的示例</a>，参照其 README 文档进行操作。</p>
<aside class="note tip">
<div class="title">提示</div>
<p>上述操作使用 YAML 配置文件创建 PyTorchTrainingJob，你也可以<a href="task/train-model/">在 Job Manager 进行创建</a>。</p>
</aside>
<h2 id="查看训练信息"><a class="header" href="#查看训练信息">查看训练信息</a></h2>
<p>训练开始后，部署一个 <a href="task/train-model/../../app/job-manager.html">Job Manager 应用</a>（如有 Job Manager 则直接复用），进入 Job Manager，可以看到名为 <strong>torch-mnist-trainingjob</strong> 的 PyTorchTrainingJob 正在运行，点击其<strong>名称</strong>进入详情页面：</p>
<figure class="screenshot">
    <img alt="running" src="task/train-model/../../assets/task/train-model/dp-training/running.png" />
</figure>
<p>可以看到刚才创建的 PyTorchTrainingJob 的基本信息、状况信息和事件信息：</p>
<figure class="screenshot">
    <img alt="details" src="task/train-model/../../assets/task/train-model/dp-training/details.png" />
</figure>
<p>点击上方的<strong>副本</strong>标签页，查看 PyTorchTrainingJob 的 Pod 信息；点击副本右侧的 <span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 16a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2m0-6a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2m0-6a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2Z"></path></svg></span><strong> &gt; 日志</strong>以查看训练脚本执行过程中的日志输出：</p>
<figure class="screenshot">
    <img alt="replicas" src="task/train-model/../../assets/task/train-model/dp-training/replicas.png" />
</figure>
<figure class="screenshot">
    <img alt="view-log" src="task/train-model/../../assets/task/train-model/dp-training/view-log.png" />
</figure>
<p>点击上方的<strong>资源监测</strong>标签页，查看 PyTorchTrainingJob 运行过程中使用集群计算资源、网络资源和存储资源的情况：</p>
<figure class="screenshot">
    <img alt="resources" src="task/train-model/../../assets/task/train-model/dp-training/resources.png" />
</figure>
<p>一段时间之后，PyTorchTrainingJob 的状态变为 <strong>Succeeded</strong>，表示训练成功完成。</p>
<figure class="screenshot">
    <img alt="done" src="task/train-model/../../assets/task/train-model/dp-training/done.png" />
</figure>
<p>若 PyTorchTrainingJob 在运行过程中出错，其状态会变为 <strong>Error</strong>，并在事件信息和 Pod 信息部分显示错误信息，此时需要根据给出的错误信息进行问题排查。</p>
<h2 id="查看训练指标"><a class="header" href="#查看训练指标">查看训练指标</a></h2>
<p>训练产生的 tfevents 文件保存在 PVC 中。回到 JupyterLab，创建一个 TensorBoard 实例。点击 TensorBoard 图标：</p>
<figure class="screenshot">
    <img alt="tensorboard1" src="task/train-model/../../assets/task/train-model/dp-training/tensorboard1.png" />
</figure>
<p>直接点击 <strong>Create TensorBoard</strong>：</p>
<figure class="screenshot">
    <img alt="tensorboard2" src="task/train-model/../../assets/task/train-model/dp-training/tensorboard2.png" />
</figure>
<p>可以查看可视化展示的训练和验证指标：</p>
<figure class="screenshot">
    <img alt="tensorboard3" src="task/train-model/../../assets/task/train-model/dp-training/tensorboard3.png" />
</figure>
<aside class="note">
<div class="title">注意</div>
<p>JupyterLab 的 TensorBoard 实例的自动更新无效，请点击右上角的 <strong>Reload 按钮</strong>以手动更新。</p>
</aside>
<aside class="note tip">
<div class="title">提示</div>
<p>你也可以部署一个 <a href="task/train-model/../../app/tensorboard.html">TensorBoard 应用</a>，展示的内容是相同的。</p>
</aside>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="进行-llm-大规模预训练"><a class="header" href="#进行-llm-大规模预训练">进行 LLM 大规模预训练</a></h1>
<p>LLM（大型语言模型）是当前 AI 领域备受瞩目的研究和应用领域。预训练是构建 LLM 的初始步骤，通常需要在 GPU 集群上进行大规模（10^3~10^4 卡）的并行训练，从而使模型获得对语言结构、语义直至语言所描述的世界和各种规律的全面理解。</p>
<p>在集群上运行大规模模型训练面临着一些关键挑战：</p>
<ul>
<li>有效地分配和管理计算资源以满足模型训练的计算需求是一项复杂任务，需要避免资源浪费和不必要的等待时间。</li>
<li>数据的并行加载和分发以及模型参数的同步和更新，需要高效的通信和协调机制，以确保训练的一致性和速度。</li>
<li>故障容错和中断恢复必不可少，因为在大规模集群上运行时硬件故障和网络问题可能导致训练中断。</li>
</ul>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/microsoft/DeepSpeed">DeepSpeed</a> 是目前最受欢迎的大规模分布式训练框架，而平台提供了 <a href="task/train-model/../modules/jobs/deepspeedjob.html">DeepSpeedJob</a>，这是专为使用 DeepSpeed 框架的分布式训练而设计的 Job 类型。</p>
<p>本教程演示使用 DeepSpeedJob 以简单快速的方式启动 Megatron-LM GPT-3 系列（125M、1.3B、13B 和 175B）模型的预训练任务。本教程对应示例 <a target="_blank" rel="noopener noreferrer" href="https://github.com/t9k/examples/tree/master/deepspeed/megatron-gpt">Megatron-DeepSpeed GPT</a>。</p>
<aside class="note info">
<div class="title">Megatron-LM</div>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/NVIDIA/Megatron-LM">Megatron-LM</a> 是 NVIDIA 应用深度学习研究团队开发的大型 transformer 代码库，用于高效地训练多达 1 trillion 参数的 LLM，并实现了多种并行技术。<a target="_blank" rel="noopener noreferrer" href="https://github.com/microsoft/Megatron-DeepSpeed">Megatron-DeepSpeed</a> 是 DeepSpeed 版本的 Megatron-LM，其增加了对几个功能的额外支持，如 MoE 训练、课程学习、3D 并行性等。</p>
<p>本示例所使用的训练代码即来自这两个项目。</p>
</aside>
<p>本教程的应用架构如下图所示：</p>
<figure class="architecture">
  <img alt="app-arch" src="task/train-model/../../assets/task/train-model/llm-large-scale-pretraining/app-arch.drawio.svg" />
</figure>
<h2 id="运行示例-1"><a class="header" href="#运行示例-1">运行示例</a></h2>
<p>创建一个名为 megatron、大小 250 GiB 以上的 PVC，然后部署一个同样名为 megatron 的 JupyterLab 应用挂载该 PVC，镜像选用 PyTorch 2 类型，计算资源申请 16 个 CPU（核心）、32 GiB 内存。</p>
<p>进入 JupyterLab，启动一个终端，前往<a target="_blank" rel="noopener noreferrer" href="https://github.com/t9k/examples/tree/master/deepspeed/megatron-gpt">本教程对应的示例</a>，参照其 README 文档进行操作。</p>
<h2 id="查看训练信息-1"><a class="header" href="#查看训练信息-1">查看训练信息</a></h2>
<p>训练开始后，部署一个 <a href="task/train-model/../../app/job-manager.html">Job Manager 应用</a>（如有 Job Manager 则直接复用），进入 Job Manager，可以看到名为 <strong>gpt-125m</strong> 的 DeepSpeedJob 正在运行，点击其<strong>名称</strong>进入详情页面：</p>
<figure class="screenshot">
    <img alt="running" src="task/train-model/../../assets/task/train-model/llm-large-scale-pretraining/running.png" />
</figure>
<p>可以看到刚才创建的 DeepSpeedJob 的基本信息、状况信息和事件信息：</p>
<figure class="screenshot">
    <img alt="details" src="task/train-model/../../assets/task/train-model/llm-large-scale-pretraining/details.png" />
</figure>
<p>点击上方的<strong>副本</strong>标签页，查看 DeepSpeedJob 的 Pod 信息；点击副本右侧的 <span class="twemoji"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 16a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2m0-6a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2m0-6a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2 2 2 0 0 1 2-2Z"></path></svg></span><strong> &gt; 日志</strong>以查看训练脚本执行过程中的日志输出：</p>
<figure class="screenshot">
    <img alt="replicas" src="task/train-model/../../assets/task/train-model/llm-large-scale-pretraining/replicas.png" />
</figure>
<figure class="screenshot">
    <img alt="view-log" src="task/train-model/../../assets/task/train-model/llm-large-scale-pretraining/view-log.png" />
</figure>
<p>点击上方的<strong>资源监测</strong>标签页，查看 DeepSpeedJob 运行过程中使用集群计算资源、网络资源和存储资源的情况：</p>
<figure class="screenshot">
    <img alt="resources" src="task/train-model/../../assets/task/train-model/llm-large-scale-pretraining/resources.png" />
</figure>
<p>一段时间之后，DeepSpeedJob 的状态变为 <strong>Succeeded</strong>，表示训练成功完成。</p>
<figure class="screenshot">
    <img alt="done" src="task/train-model/../../assets/task/train-model/llm-large-scale-pretraining/done.png" />
</figure>
<p>训练完成之后，模型文件将保存到 <code>output/gpt-125m/model</code> 路径下，后续用于<a target="_blank" rel="noopener noreferrer" href="https://github.com/t9k/examples/tree/master/deepspeed/megatron-gpt#%E6%96%87%E6%9C%AC%E7%94%9F%E6%88%90">文本生成</a>或进一步的微调。</p>
<p>若 DeepSpeedJob 在运行过程中出错，其状态会变为 <strong>Error</strong>，并在事件信息和 Pod 信息部分显示错误信息，此时需要根据给出的错误信息进行问题排查。</p>
<h2 id="查看训练指标-1"><a class="header" href="#查看训练指标-1">查看训练指标</a></h2>
<p>训练产生的 tfevents 文件保存在 <code>output/gpt-125m/tensorboard</code> 路径下，可以<a href="task/train-model/./dp-training.html#%E6%9F%A5%E7%9C%8B%E8%AE%AD%E7%BB%83%E6%8C%87%E6%A0%87">在 JupyterLab 中创建一个 TensorBoard 实例</a>或部署一个 <a href="task/train-model/../../app/tensorboard.html">TensorBoard 应用</a>以查看：</p>
<figure class="screenshot">
  <img alt="tensorboard" src="task/train-model/../../assets/task/train-model/llm-large-scale-pretraining/tensorboard.png" />
</figure>
<h2 id="使用其他训练配置"><a class="header" href="#使用其他训练配置">使用其他训练配置</a></h2>
<p><code>examples/deepspeed/megatron-gpt/training</code> 路径下有多个 YAML 配置文件，分别对应不同模型参数量的不同并行训练策略，细节如下表所示：</p>
<div class="table-wrapper"><table><thead><tr><th>参数量</th><th>训练 token 量</th><th>数据集</th><th>配置文件</th><th>并行策略</th><th>GPU 使用（参考）</th><th>预计时间*</th></tr></thead><tbody>
<tr><td>125M</td><td>2.5B</td><td>enwiki</td><td><code>gpt-125m.yaml</code></td><td>-</td><td>1x A100 40GB</td><td>~8h</td></tr>
<tr><td></td><td></td><td></td><td><code>gpt-125m-2xdp.yaml</code></td><td>2x数据并行</td><td>2x A100 40GB</td><td>~4h</td></tr>
<tr><td></td><td></td><td></td><td><code>gpt-125m-4xdp.yaml</code></td><td>4x数据并行</td><td>4x A100 40GB</td><td>~2h</td></tr>
<tr><td>1.3B</td><td>26B</td><td>enwiki</td><td><code>gpt-1-3b-4xdp.yaml</code></td><td>4x数据并行</td><td>4x A100 40GB</td><td>~8d</td></tr>
<tr><td></td><td></td><td></td><td><code>gpt-1-3b-8xdp.yaml</code></td><td>8x数据并行</td><td>8x A100 40GB</td><td>~4d</td></tr>
<tr><td></td><td></td><td></td><td><code>gpt-1-3b-4xdp-4xpp.yaml</code></td><td>4x数据并行 + 4x流水线并行</td><td>2x 8x A100 40GB</td><td></td></tr>
<tr><td>13B</td><td>260B</td><td>enwiki</td><td><code>gpt-13b-4xdp-4xpp.yaml</code></td><td>4x数据并行 + 4x流水线并行</td><td>2x 8x A100 80GB</td><td></td></tr>
<tr><td></td><td></td><td></td><td><code>gpt-13b-4xdp-8xpp.yaml</code></td><td>4x数据并行 + 8x流水线并行</td><td>4x 8x A100 80GB</td><td></td></tr>
<tr><td></td><td></td><td></td><td><code>gpt-13b-4xdp-4xpp-4xtp.yaml</code></td><td>4x数据并行 + 4x流水线并行 + 4x张量并行</td><td>8x 8x A100 80GB</td><td></td></tr>
<tr><td>175B</td><td>3.5T</td><td></td><td>(WIP)</td><td></td><td></td><td></td></tr>
</tbody></table>
</div><p style="color: gray; font-size: 14px">*预计时间为参考值，与具体的硬件环境有关，这里以 A100 PCIE 40GB GPU 节点为例</p>
<h2 id="参考-1"><a class="header" href="#参考-1">参考</a></h2>
<ul>
<li><a target="_blank" rel="noopener noreferrer" href="https://github.com/NVIDIA/Megatron-LM">Megatron-LM</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://github.com/microsoft/Megatron-DeepSpeed">Megatron-DeepSpeed</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://github.com/microsoft/DeepSpeed">DeepSpeed</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="分析性能"><a class="header" href="#分析性能">分析性能</a></h1>
<p>PyTorch 提供的 <a target="_blank" rel="noopener noreferrer" href="https://pytorch.org/docs/stable/profiler.html">profiler 工具</a>允许在训练和推理过程中收集性能指标，帮助开发者识别代码中的性能瓶颈和优化机会。它可以测量 CPU 和 GPU 上的操作执行时间、内存使用情况以及其他硬件利用率指标。通过使用 profiler，用户可以详细分析每个操作的耗时，追踪张量形状和类型，并生成可视化报告来直观地展示性能数据。这使得开发者能够更好地理解模型的运行特性，从而进行针对性的优化，提高模型的训练和推理效率。用户在 <a href="task/train-model/../../app/jupyter-lab.html">JupyterLab 应用</a>中可以方便地使用这一工具。</p>
<p>本教程演示在 JupyterLab 应用中对<a href="task/train-model/./llm-large-scale-pretraining.html">进行 LLM 大规模预训练</a>中的训练进行性能分析。</p>
<h2 id="准备工作-1"><a class="header" href="#准备工作-1">准备工作</a></h2>
<p>在<a href="task/train-model/../examples/start-llm-large-scale-pretraining.html">进行 LLM 大规模预训练</a>给出的准备工作的基础上，还需要修改 Megatron-DeepSpeed 的训练代码，用 profiler 上下文管理器包装训练循环的代码。直接使用 Notebook 的文本编辑器修改代码即可。</p>
<pre><code class="language-python"># Megatron-DeepSpeed/megatron/training.py
...

    profile_path = os.path.join(os.path.dirname(args.tensorboard_dir), 'profiling')

    with torch.profiler.profile(
            schedule=torch.profiler.schedule(wait=1, warmup=1, active=3, repeat=2),
            on_trace_ready=torch.profiler.tensorboard_trace_handler(profile_path),
            record_shapes=True,
            profile_memory=True,
            with_stack=True,
            with_flops=True,
            with_modules=True
    ) as prof:  # profiler context manager
        while iteration &lt; args.train_iters and (args.train_tokens is None or \
            args.consumed_train_tokens &lt; args.train_tokens):  # training loop

            ...

            prof.step()

...
</code></pre>
<p>其中对于 profiler 的配置为：</p>
<ul>
<li>profiler 跳过 1 个 step，热身 1 个 step，然后记录 3 个 step；总共重复 2 次。</li>
<li>生成用于 TensorBoard 展示的结果文件，与 TensorBoard 日志文件保存到同一父目录下。</li>
<li>记录算子的源信息和输入形状，记录模块（module）的调用栈，估计 FLOPS，跟踪张量内存的分配和释放。</li>
</ul>
<h2 id="启动性能分析"><a class="header" href="#启动性能分析">启动性能分析</a></h2>
<p>以 4 个 GPU 训练 125M 参数的 GPT 模型，启动训练：</p>
<pre><code class="language-bash">kubectl create -f \
  examples/deepspeed/megatron-gpt/training/gpt-125m-4xdp.yaml
</code></pre>
<p>通过以下命令查看训练过程中打印的日志：</p>
<pre><code class="language-bash">export POD=$(kubectl get dj gpt-125m -o jsonpath=&quot;{.status.tasks[0].replicas[0].name}&quot;)
kubectl logs $POD -f
</code></pre>
<figure class="screenshot">
  <img alt="log" src="task/train-model/../../assets/task/train-model/profile/log.png" />
</figure>
<p>性能分析完成之后，结果文件被保存在 <code>output/gpt-125m-4xdp/profiling</code> 路径下，前往该路径并启动一个 TensorBoard 实例以查看可视化结果。</p>
<figure class="screenshot">
  <img alt="create-tensorboard" src="task/train-model/../../assets/task/train-model/profile/create-tensorboard.png" />
</figure>
<h2 id="查看可视化结果"><a class="header" href="#查看可视化结果">查看可视化结果</a></h2>
<p>Overview 展示了训练性能的总体情况，包含 GPU 的总体情况、不同执行类别花费的时间和占比，以及自动生成的性能优化建议：</p>
<figure class="screenshot">
  <img alt="overview" src="task/train-model/../../assets/task/train-model/profile/overview.png" />
</figure>
<p><img src="task/train-model/../../assets/task/train-model/profile/" alt="" /></p>
<p>Operator View 展示了所有 PyTorch 算子被调用的次数、花费的时间以及它的调用栈：</p>
<figure class="screenshot">
  <img alt="operator-view" src="task/train-model/../../assets/task/train-model/profile/operator-view.png" />
</figure>
<p>Kernel View 展示了所有 GPU 内核被调用的次数、花费的时间的统计以及它是否使用了 Tensor Core 等：</p>
<figure class="screenshot">
  <img alt="kernel-view" src="task/train-model/../../assets/task/train-model/profile/kernel-view.png" />
</figure>
<p>Memory View 展示了内存使用曲线图、内存事件（分配和释放）以及内存统计数据：</p>
<figure class="screenshot">
  <img alt="memory-view" src="task/train-model/../../assets/task/train-model/profile/memory-view.png" />
</figure>
<p>TensorBoard 所展示的数据和提供的功能还远不止这些，请参阅<a target="_blank" rel="noopener noreferrer" href="https://pytorch.org/tutorials/intermediate/tensorboard_profiler_tutorial.html">官方教程</a>以了解更多。这些数据应当能为用户分析和改进性能提供非常有用的帮助。</p>
<h2 id="参考-2"><a class="header" href="#参考-2">参考</a></h2>
<ul>
<li><a target="_blank" rel="noopener noreferrer" href="https://pytorch.org/tutorials/beginner/profiler.html">Profiling your PyTorch Module</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://pytorch.org/tutorials/recipes/recipes/profiler_recipe.html">PyTorch Profiler</a></li>
<li><a target="_blank" rel="noopener noreferrer" href="https://pytorch.org/docs/stable/profiler.html">torch.profiler</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署模型推理服务"><a class="header" href="#部署模型推理服务">部署模型推理服务</a></h1>
<p>这一部分的任务涉及将深度学习模型部署为推理服务。在这些任务中，你将部署时下流行的模型并使用到多种高级功能，具体包括：</p>
<ol>
<li>使用平台提供的 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/deployment/mlservice.html">MLService</a> 和 <a target="_blank" rel="noopener noreferrer" href="https://t9k.github.io/user-manuals/latest/modules/deployment/simplemlservice.html">SimpleMLService</a> API，在多种推理框架下进行部署</li>
<li>通过部署<a href="task/deploy-model/../../app/index.html">应用</a>来快速搭建 LLM 推理服务</li>
<li>通过可视化界面查看推理服务信息，实时监控计算资源使用和性能指标</li>
<li>实施多版本发布和金丝雀发布策略，确保服务的平稳过渡和风险控制</li>
<li>配置自动伸缩机制，动态调整服务容量以适应负载变化，优化计算资源使用</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="部署-llm-推理服务和聊天服务"><a class="header" href="#部署-llm-推理服务和聊天服务">部署 LLM 推理服务和聊天服务</a></h1>
<p>本教程演示使用 vLLM 应用简单快速地将 Meta-Llama-3.1-8B-Instruct 模型部署为推理服务，再使用 NextChat 应用提供一个简洁美观并且提供扩展功能的聊天 UI。</p>
<p>本教程的应用架构如下图所示：</p>
<figure class="architecture">
  <img alt="app-arch" src="task/deploy-model/../../assets/task/deploy-model/deploy-llm/app-arch.drawio.svg" />
</figure>
<h2 id="准备工作-2"><a class="header" href="#准备工作-2">准备工作</a></h2>
<p>创建一个名为 vllm、大小 18GiB 的 PVC，然后部署一个任意的 JupyterLab 应用挂载该 PVC。</p>
<p>进入 JupyterLab 应用，启动一个终端，执行以下命令以下载模型文件：</p>
<pre><code class="language-bash">pip install modelscope

MODEL_NAME=Meta-Llama-3.1-8B-Instruct
modelscope download --model &quot;LLM-Research/$MODEL_NAME&quot; --exclude &quot;original/*&quot; --local_dir &quot;./$MODEL_NAME&quot;
</code></pre>
<h2 id="部署-vllm-应用"><a class="header" href="#部署-vllm-应用">部署 vLLM 应用</a></h2>
<p>进入应用目录，点击 <strong>vLLM</strong> 应用，进入 README 页面：</p>
<figure class="screenshot">
  <img alt="catalog-vllm" src="task/deploy-model/../../assets/task/deploy-model/deploy-llm/catalog-vllm.png" />
</figure>
<p>README 给出了应用介绍、使用方法、配置示例和参数说明，根据这些信息写出 YAML 配置如下：</p>
<pre><code class="language-yaml">replicaCount: 1

image:
  registry: docker.io
  repository: vllm/vllm-openai
  tag: &quot;v0.5.3.post1&quot;
  pullPolicy: IfNotPresent

resources:
  limits:
    cpu: 4
    memory: 64Gi
    nvidia.com/gpu: 1

model:
  deployName: &quot;llama3-1-8b&quot;  # 模型以该名称被部署

  volume:
    existingClaim: &quot;vllm&quot;
    subPath: &quot;Meta-Llama-3.1-8B-Instruct&quot;

env: []
</code></pre>
<p>使用上述配置部署 vLLM 应用，待应用就绪后，查看其信息：</p>
<figure class="screenshot">
  <img alt="vllm-info" src="task/deploy-model/../../assets/task/deploy-model/deploy-llm/vllm-info.png" />
</figure>
<p>回到 JupyterLab，在终端中执行上述命令：</p>
<figure class="screenshot">
  <img alt="send-request" src="task/deploy-model/../../assets/task/deploy-model/deploy-llm/send-request.png" />
</figure>
<p>可以看到推理服务正常返回响应。</p>
<aside class="note tip">
<div class="title">提示</div>
<p>上述操作同时记载于 vLLM (Llama 3.1) 应用的使用方法，该应用是 vLLM 应用的变体，专门用于部署 Llama 3.1 系列模型。本教程选择更加通用的 vLLM 应用作为演示，vLLM 应用可以部署大多数流行的开源模型。</p>
</aside>
<h2 id="部署-nextchat-应用"><a class="header" href="#部署-nextchat-应用">部署 NextChat 应用</a></h2>
<p>为了让聊天有一个简洁而美观的 UI，我们可以使用 NextChat 应用。进入应用目录，点击 <strong>NextChat</strong> 应用：</p>
<figure class="screenshot">
  <img alt="catalog-nextchat" src="task/deploy-model/../../assets/task/deploy-model/deploy-llm/catalog-nextchat.png" />
</figure>
<p>根据 README 写出 YAML 配置如下：</p>
<pre><code class="language-yaml">replicaCount: 1

image:
  registry: docker.io
  repository: yidadaa/chatgpt-next-web
  tag: v2.12.2
  pullPolicy: IfNotPresent

service:
  type: ClusterIP
  port: 3000

resources:
  limits:
    cpu: 1
    memory: 2Gi

llm:
  provider: &quot;openai&quot;
  apiKey: &quot;any&quot;
  openai:
    baseUrl: &quot;http://&lt;ENDPOINT&gt;&quot;  # 根据 vLLM 应用的信息获取服务端点

env: []
</code></pre>
<p>使用上述配置部署 NextChat 应用，待应用就绪后，查看其信息：</p>
<figure class="screenshot">
  <img alt="nextchat-info" src="task/deploy-model/../../assets/task/deploy-model/deploy-llm/nextchat-info.png" />
</figure>
<p>在本地的终端中执行上述命令，然后在浏览器中访问相应的地址进入 UI，在设置中填写模型被部署的名称并选择该模型：</p>
<figure class="screenshot" style="text-align: center;">
  <img alt="nextchat-config" src="task/deploy-model/../../assets/task/deploy-model/deploy-llm/nextchat-config.png" width="80%" />
</figure>
<p>然后就可以开始聊天了！</p>
<figure class="screenshot" style="text-align: center;">
  <img alt="nextchat-chat" src="task/deploy-model/../../assets/task/deploy-model/deploy-llm/nextchat-chat.png" width="80%" />
</figure>
<h2 id="参考-3"><a class="header" href="#参考-3">参考</a></h2>
<ul>
<li>NextChat：<a target="_blank" rel="noopener noreferrer" href="https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web">https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web</a></li>
<li>vLLM：<a target="_blank" rel="noopener noreferrer" href="https://github.com/vllm-project/vllm">https://github.com/vllm-project/vllm</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/sidebar.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
